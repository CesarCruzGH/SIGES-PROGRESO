   INSTITUTO TECNOLÓGICO SUPERIOR PROGRESO
   ORGANISMO PÚBLICO DESCENTRALIZADO DEL GOBIERNO DEL ESTADO
   CLAVE: 31ETI0004Q
  
  
  SIGES-PROGRESO SISTEMA ELECTRÓNICO DE EXPEDIENTES CLÍNICOS
  INFORME TÉCNICO DE RESIDENCIA PROFESIONAL
  
  CARRERA
  LICENCIATURA EN SISTEMAS COMPUTACIONALES
  
  RESIDENTE
  CESAR URIEL CRUZ CANUL
  
  ASESOR(A) EXTERNO
  MTI. JOSÉ EMILIANO TUYIN ANGUAS
  
  ASESOR(A) INTERNO
  MTRA. LIGIA BREATIZ CHUC-US
  
  Progreso, Yucatán
  2025
  

CARTA TERMINACIÓN


  

CONTENIDO
  Carta terminación	ii
  Contenido	iii
  Índice de tablas y figuras	v
  Resumen	vi
  CAPÍTULO I. INTRODUCCIÓN	1
  Justificación	1
  Objetivos	2
  Objetivo General	2
  Objetivos Específicos	2
  Fundamento teórico	3
  CAPÍTULO II. IDENTIFICACIÓN DE LA PROBLEMÁTICA	28
  Características del área	28
  Identificación de la problemática	32
  Alcances y limitaciones	34
  Alcances del Proyecto:	34
  Limitaciones del Proyecto:	34
  Capítulo III. Metodología	36
  Procedimiento y descripción de las actividades realizadas	36
  Sprint 1: Digitalización de expedientes	36
  Priorización de historias de usuario para la digitalización de expedientes	36
  Desarrollo de la Historia de Usuario SM-1: Estructurar el Núcleo de Datos Clínicos.	37
  Desarrollo de la Historia de Usuario SM-2: Registrar Datos de Pacientes Nuevos	50
  Desarrollo de la Historia de Usuario SM-3: Implementar la Gestión de Citas	64
  Desarrollo de la Historia de Usuario SM-4: Habilitar el Alta Rápida de Pacientes desde el Módulo de Citas	75
  Desarrollo de la Historia de Usuario SM-5: Registrar Atenciones Clínicas Iniciales (Somatometría)	76
  Desarrollo de la Historia de Usuario SM-6: Gestionar el Expediente y Atenciones por Servicio	78
  Sprint 2: Reportes y Business Intelligence (BI)	80
  Priorización de historias de usuario para reportes y BI	80
  Desarrollo de la Historia de Usuario SM-7: Monitorear la Actividad Diaria en Tiempo Real	81
  Desarrollo de la Historia de Usuario SM-8: Analizar Indicadores Clave de Rendimiento (KPIs) a través de Gráficas	82
  Desarrollo de la Historia de Usuario SM-9: Exportar Datos Detallados para Análisis Externo	92

  

ÍNDICE DE TABLAS Y FIGURAS
TABLAS
TABLA 1: prueba	¡Error! Marcador no definido.
FIGURAS



  
  
  

RESUMEN
  En este momento, aún no he redactado los resultados, el análisis ni las conclusiones finales del proyecto. Intentar resumirlos ahora sería especular.


CAPÍTULO I. INTRODUCCIÓN
Justificación
  La justificación para el desarrollo del Sistema Electrónico de Expedientes Clínicos para los Servicios de Salud del H. Ayuntamiento de Progreso se fundamenta, en primer lugar, en la magnitud del problema operativo que enfrenta la Dirección de Salud Municipal del H. Ayuntamiento de Progreso. La dependencia opera una red multidisciplinaria que incluye servicios de medicina general, psicología, nutrición y odontología. Tan solo el área de consulta médica general gestiona un volumen superior a los 1,200 registros clínicos cada mes, todos bajo un esquema completamente manual. Esta situación afecta a una amplia base de usuarios, compuesta en gran parte por la población en situación de vulnerabilidad del municipio, evidenciando que no se trata de una deficiencia menor, sino de un desafío a gran escala que impacta directamente en la calidad de los servicios de salud pública.
  Precisamente por esta escala, la trascendencia de esta problemática va más allá de la simple ineficiencia. El sistema manual actual expone a la institución a una considerable vulnerabilidad operativa y legal. La falta de un control digitalizado sobre los expedientes compromete la confidencialidad de datos sensibles, contraviniendo los principios de la Ley General de Protección de Datos Personales en Posesión de Sujetos Obligados. La ausencia de trazabilidad sobre el acceso a la información y la generación de estadísticas mediante métodos manuales y propensos a errores no solo ralentiza la toma de decisiones, sino que también debilita la integridad de la data clínica. De no atenderse, este rezago tecnológico amenaza con perpetuar un servicio que afecta el derecho de la ciudadanía a una atención segura y oportuna, volviéndose una práctica insostenible ante la creciente demanda.
  Frente a este panorama de riesgos y prácticas insostenibles, la realización de este proyecto es completamente factible. Por un lado, se cuenta con el respaldo institucional del H. Ayuntamiento de Progreso, que ha facilitado los recursos básicos para iniciar, incluyendo un equipo destinado a funcionar como servidor local. Por otro lado, el desarrollo técnico se sustenta en las competencias del residente de Ingeniería en Sistemas Computacionales, quien implementará un entorno de desarrollo integral y moderno. Este entorno se compone de un stack de backend robusto basado en PHP y el framework Laravel, un gestor de bases de datos relacional como PostgreSQL, y herramientas de contenedorización como Docker para garantizar la consistencia a lo largo del proyecto. La gestión de las actividades se apoyará en plataformas de trabajo colaborativo como Jira, asegurando que el alcance, delimitado de forma realista al periodo de 15 semanas de la residencia, se cumpla de manera ordenada y eficiente.
Objetivos
Objetivo General
  Desarrollar un sistema web que optimice la gestión de la información clínica, asegure la privacidad de los datos sensibles de los ciudadanos y provea Inteligencia de negocio para la entrega de servicios de salud municipal del H. Ayuntamiento de Progreso.
Objetivos Específicos
1. Optimizar la gestión de historiales clínicos mediante la digitalización de expedientes, la centralización de atenciones multidisciplinarias y la sistematización de flujos operativos clínico-administrativos en un entorno web. 
2. Asegurar la confidencialidad, integridad y trazabilidad de los datos clínicos mediante autenticación robusta, control de acceso basado en roles (RBAC), cifrado de información sensible y registros de auditoría del sistema buscando la protección de los datos de acuerdo con recomendaciones de la LGPDP. 
3. Proveer inteligencia operativa al personal médico y administrativo mediante un módulo de análisis clínico-demográfico, y un panel de mando que apoye en la toma de decisiones en los programas de salud municipal. 
Fundamento teórico
  El desarrollo del "Sistema Electrónico de Expedientes Clínicos para los Servicios de Salud del H. Ayuntamiento de Progreso" se sustenta en un conjunto de conocimientos, metodologías y tecnologías adquiridas durante la formación académica. Este apartado desglosa los conceptos teóricos fundamentales que sirvieron como pilar para el diseño, la implementación y el análisis del proyecto, demostrando la vinculación directa entre la teoría de la Ingeniería de Software y la práctica ejecutada en un entorno real del sector público. Los conceptos se agrupan en cinco pilares temáticos.
1. Metodología y Arquitectura de Software Moderna
  El desarrollo de software moderno se articula frecuentemente en torno a las metodologías ágiles. Estos enfoques surgieron como una respuesta a las limitaciones de los modelos de desarrollo tradicionales, como el modelo en cascada (Waterfall). Beck et al. (2001) documentaron la filosofía central de este movimiento en el Manifiesto Ágil, el cual se basa en cuatro valores fundamentales, priorizando la colaboración con el cliente sobre la negociación contractual y la respuesta ante el cambio sobre el seguimiento de un plan.
  Esta filosofía se desglosa en doce principios, entre los que destacan la entrega temprana y continua de software funcional, la colaboración diaria entre los desarrolladores y los interesados del negocio, y la aceptación de que los requisitos pueden cambiar incluso en fases avanzadas del desarrollo.
  La principal diferencia con los modelos tradicionales radica en la gestión de la incertidumbre. Moniruzzaman y Hossain (2013) comparan ambos enfoques y señalan la rigidez del modelo en cascada, donde los requisitos deben ser especificados en su totalidad al inicio del proyecto. Los autores destacan la ventaja de la agilidad en entornos dinámicos:
  En metodologías tradicionales como cascada, los requisitos se especifican completamente al inicio del proyecto y se documentan de forma exhaustiva. Cualquier cambio requiere un proceso formal de solicitud de cambio que puede ralentizar significativamente el proyecto. En contraste, las metodologías ágiles reconocen que los requisitos son emergentes y evolucionan continuamente.
  La vinculación con la práctica de este proyecto es directa. El desarrollo de un sistema para una entidad gubernamental como el H. Ayuntamiento de Progreso se alinea con los desafíos identificados en la literatura académica. Looks et al. (2021) documentan que la adopción ágil en proyectos de e-government es desafiante debido a estructuras jerárquicas rígidas y procesos de contratación que exigen especificaciones completas por adelantado. De manera similar, Kokol et al. (2022) señalan que, aunque los sistemas de salud digital se beneficiarían enormemente de los enfoques ágiles, su adopción es limitada por la necesidad de gestionar un alto volumen de stakeholders y cumplir con regulaciones estrictas de interoperabilidad y seguridad. Por lo tanto, la elección de una metodología ágil para este proyecto no fue trivial, sino una decisión estratégica para gestionar la complejidad y los requisitos emergentes del personal de salud (los stakeholders), permitiendo la entrega de módulos funcionales (Sprints) que se adaptaron a las necesidades reales observadas en la Dirección de Salud Municipal.
1.2. El Patrón Modelo-Vista-Controlador (MVC) en Laravel
  En su conceptualización moderna para aplicaciones empresariales, Fowler (2002) define los tres componentes: "el Modelo contiene la funcionalidad y datos centrales, la Vista presenta la información al usuario, y el Controlador maneja las entradas del usuario". Si bien el patrón clásico de Reenskaug estaba diseñado para interfaces gráficas de usuario con estado, los frameworks web modernos han adaptado este patrón al contexto sin estado (stateless) del protocolo HTTP. En esta adaptación, el Modelo se implementa comúnmente mediante un Mapeador Objeto-Relacional (ORM), la Vista mediante un motor de plantillas que genera HTML, y el Controlador responde a rutas HTTP para coordinar la solicitud. El patrón de arquitectura de software Modelo-Vista-Controlador (MVC) es un pilar fundamental en la ingeniería de software moderna para el desarrollo de aplicaciones interactivas. Introducido originalmente por Reenskaug (1979) en el contexto de Smalltalk en Xerox PARC, su propósito era crear una arquitectura que separara la lógica de negocio de su presentación visual y de la lógica de interacción del usuario. Esta separación de intereses (separation of concerns) es su principio fundamental, permitiendo que cada componente evolucione de manera independiente, lo cual incrementa la mantenibilidad, la reusabilidad y la capacidad de realizar pruebas en el software.
  La vinculación con la práctica en el "Sistema Electrónico de Expedientes Clínicos para los Servicios de Salud del H. Ayuntamiento de Progreso" es directa, ya que se construye sobre el framework Laravel (Otwell, 2011-presente), el cual implementa explícitamente el patrón MVC. El Modelo se materializa a través de Eloquent ORM, donde clases como Patient.php o Appointment.php encapsulan la lógica de acceso a datos y las relaciones, abstrayendo la complejidad de SQL. La Vista se gestiona a través de los componentes de Filament y Livewire, que a su vez utilizan el motor de plantillas Blade para renderizar la interfaz de usuario interactiva. Finalmente, el Controlador se implementa en clases como los Resources de Filament (ej. PatientResource.php) y controladores de API (ej. ApiController.php), que manejan las rutas, validan las entradas del usuario y coordinan la respuesta.
  La adopción de esta arquitectura no es solo una decisión de organización, sino también un pilar de ciberseguridad. El componente Modelo (Eloquent) proporciona protección automática contra ataques de Inyección SQL al parametrizar todas las consultas. A su vez, el componente Vista (Blade) mitiga los ataques de Cross-Site Scripting (XSS) al escapar automáticamente todas las variables renderizadas por defecto. Por lo tanto, la elección de una arquitectura MVC probada como la de Laravel es un fundamento clave para construir un sistema robusto, mantenible y seguro.
1.3. Arquitectura de Componentes Reactivos (Livewire y Filament)
  Un pilar fundamental en el desarrollo de interfaces web modernas es la arquitectura de componentes reactivos. Este paradigma organiza la interfaz de usuario en componentes autónomos que reaccionan automáticamente a los cambios en el estado de la aplicación. En los frameworks tradicionales del lado del cliente, como React o Vue.js, este enfoque resuelve el complejo problema de mantener la interfaz de usuario sincronizada con el estado que reside en el navegador. Como lo describe Sommerville (2015), la arquitectura de componentes facilita la organización de sistemas complejos al reducir el acoplamiento entre las distintas partes de la interfaz.
  El "Sistema Electrónico de Expedientes Clínicos" adopta una evolución de este paradigma: la reactividad del lado del servidor, implementada a través del framework Livewire (Porzio, 2023). A diferencia de las SPAs (Single Page Applications), Livewire mantiene el estado de los componentes en el servidor, no en el navegador. Porzio (2023) explica que este enfoque, conocido como "HTML-over-the-wire", permite a los desarrolladores PHP construir interfaces interactivas complejas sin escribir JavaScript personalizado; cuando un usuario interactúa con la página, Livewire envía una solicitud al servidor, recalcula el componente y envía de vuelta únicamente las diferencias ("diffs") del HTML, actualizando el DOM de forma quirúrgica. Esta arquitectura no solo simplifica el desarrollo, sino que inherentemente mejora la seguridad, ya que la lógica de negocio sensible permanece en el servidor y no se expone al cliente.
  Livewire es el componente central del ecosistema conocido como el TALL Stack, un acrónimo que define una arquitectura cohesiva para el desarrollo full-stack. Según TALL Stack Contributors (2024), "El TALL Stack combina Tailwind CSS para estilos, Alpine.js para interactividad ligera, Laravel como backend, y Livewire para componentes reactivos del servidor, creando un ecosistema cohesivo para desarrollo full-stack moderno". En esta arquitectura, Alpine.js juega un rol crucial al gestionar interacciones de interfaz triviales (como mostrar u ocultar un menú) sin necesidad de una costosa llamada al servidor, complementando la lógica de estado de Livewire.
  La vinculación con la práctica de este proyecto se materializa a través de Filament (Harrin et al., 2024). Filament es un constructor de paneles de administración de alto nivel construido enteramente sobre el TALL Stack. En lugar de construir cada componente reactivo manualmente, el proyecto utiliza la sintaxis declarativa de Filament para generar interfaces complejas. Como lo describen Harrin et al. (2024), Filament es "un conjunto de componentes Livewire predefinidos y composables que permite a los desarrolladores construir interfaces de administración complejas, incluyendo tablas de datos con búsqueda y filtrado, [y] formularios con validación en tiempo real [...] sin requerir escritura de código JavaScript o HTML personalizado". Por lo tanto, cada vez que en el sistema un formulario valida un campo en tiempo real (->live()) o una tabla filtra datos de forma interactiva, es la aplicación directa de la arquitectura de componentes reactivos del TALL Stack, demostrando la unión de la teoría de componentes y la práctica del desarrollo rápido de aplicaciones.
1.4. El Patrón Observador (Events & Listeners) para Lógica de Negocio
  El Patrón Observador (Observer Pattern) es un patrón de diseño de comportamiento fundamental, canonizado por Gamma, Helm, Johnson y Vlissides (1994) en su obra seminal sobre patrones de diseño. El propósito central del patrón es definir una dependencia de uno-a-muchos entre objetos, de modo que cuando un objeto (el "Sujeto") cambia de estado, todos sus dependientes (los "Observadores") son notificados y actualizados automáticamente. Esto permite una comunicación desacoplada, ya que el sujeto no necesita conocer la identidad o la lógica de sus observadores, solo necesita notificar que un cambio ha ocurrido.
  El beneficio principal de esta arquitectura es el desacoplamiento (decoupling). Autores de ingeniería de software como Pressman y Maxim (2014) explican que el patrón permite que el sujeto y sus observadores varíen de forma independiente, reduciendo las dependencias explícitas y mejorando drásticamente la mantenibilidad del código. Esta teoría evoluciona en las arquitecturas modernas hacia los sistemas dirigidos por eventos (Event-Driven Architecture), donde, como describe Newman (2015), un despachador de eventos (Event Dispatcher) actúa como el "Sujeto" y los "Escuchadores" (Listeners) actúan como los "Observadores". Esto permite que múltiples subsistemas reaccionen a un solo evento sin que la fuente original del evento necesite saber de su existencia, creando sistemas más extensibles y resilientes.
  La vinculación con la práctica en el "Sistema Electrónico de Expedientes Clínicos para los Servicios de Salud del H. Ayuntamiento de Progreso" es extensa y se utiliza para automatizar la lógica de negocio y garantizar la integridad de los datos. El framework Laravel implementa el Patrón Observador a través de su sistema explícito de Eventos y Escuchadores, y de manera implícita, a través de los eventos del ciclo de vida de los modelos Eloquent. Otwell (2021) explica que este sistema permite que una acción principal (ej. "Paciente Registrado") desencadene múltiples procesos secundarios (ej. "Enviar Email", "Crear Expediente") sin que el controlador original tenga conocimiento de ellos, simplificando el código y aumentando el modularidad. En la práctica del proyecto, este patrón es visible en: 1) El modelo Patient, que al disparar el evento created, es "observado" por un escuchador que automáticamente crea el MedicalRecord asociado. 2) El modelo MedicalRecord, que en su evento creating es "observado" por una lógica que genera el folio único (record_number) consultando una secuencia de PostgreSQL. 3) El modelo Appointment, que en su evento creating genera un número de ticket (ticket_number) para pacientes "walk-in".
2. Diseño y Administración de Bases de Datos Relacionales
2.1. Diseño de Esquemas y Normalización
  El fundamento de cualquier sistema de información robusto reside en su modelo de datos. Históricamente, los sistemas de bases de datos se basaban en modelos jerárquicos o de red, los cuales presentaban problemas significativos de rigidez y dependencia de la implementación física. Codd (1970) revolucionó este campo al proponer el modelo relacional, cuyo objetivo principal era establecer un paradigma que permitiera la "independencia de datos", facilitando que la estructura lógica de los datos pudiera evolucionar sin afectar a las aplicaciones que los consumían. Este modelo, que se ha convertido en el estándar de la industria, se basa en el concepto de "relaciones" (tablas) para organizar los datos de forma flexible.
  Una consecuencia directa del modelo relacional es el proceso de normalización. El propósito fundamental de la normalización es organizar los datos de manera que se reduzca la redundancia y se mejore la integridad de los datos (Silberschatz et al., 2011). Un esquema de base de datos que no está normalizado sufre de "anomalías de modificación" (Elmasri & Navathe, 2016). Estas anomalías se clasifican en tres tipos: de inserción (dificultad para registrar una entidad sin otra), de borrado (pérdida accidental de datos al eliminar un registro) y de actualización (necesidad de modificar el mismo dato en múltiples filas, creando un alto riesgo de inconsistencia).
  El proceso para alcanzar un diseño normalizado implica seguir una serie de reglas conocidas como Formas Normales. La Primera Forma Normal (1NF) exige que todos los atributos sean atómicos. La Segunda Forma Normal (2NF) elimina las dependencias parciales de una clave compuesta. La Tercera Forma Normal (3NF), que suele ser el objetivo estándar para la mayoría de las aplicaciones empresariales, se logra al eliminar las dependencias transitivas, es decir, cuando un atributo no clave depende de otro atributo que tampoco es clave (Silberschatz et al., 2011).
  La vinculación con la práctica de estos conceptos teóricos es la piedra angular del "Sistema Electrónico de Expedientes Clínicos para los Servicios de Salud del H. Ayuntamiento de Progreso". El diseño del esquema en PostgreSQL se adhiere estrictamente a los principios de normalización para garantizar la integridad de la información clínica, un requisito no negociable en el sector salud. Por ejemplo, en lugar de almacenar el nombre del paciente, su CURP, el número de expediente y el motivo de la consulta en una sola tabla "gigante" (un diseño no normalizado), el sistema aplica la 3NF al descomponer los datos en entidades lógicas: patients (datos biográficos), medical_records (datos del contenedor clínico) y appointments (datos del evento de la cita). Este diseño previene directamente las anomalías:
* Previene la Anomalía de Actualización: Si el nombre de un paciente cambia, se actualiza en un solo registro en la tabla patients, en lugar de tener que modificar cientos de registros en la tabla appointments.
* Previene la Anomalía de Borrado: Se puede eliminar una cita (appointments) sin que ello implique la eliminación del historial del paciente (patients), y viceversa.
* Previene la Anomalía de Inserción: Se puede registrar a un paciente (patients) en el sistema por primera vez, incluso antes de que tenga su primera cita (appointments) agendada.
2.2. Garantía de la Integridad Referencial (Foreign Keys, cascade vs restrict)
  Una vez que un esquema de base de datos se ha normalizado, el siguiente paso crítico para garantizar la consistencia de los datos es la implementación de la integridad referencial. Este es un principio fundamental del modelo relacional que asegura que las relaciones entre las tablas se mantengan coherentes. Formalmente, la integridad referencial dicta que si una tabla (la tabla "hijo" o referenciante) contiene una clave foránea (foreign key), el valor de esta clave debe corresponder a un valor existente en la clave primaria de la tabla "padre" (referenciada), o bien debe ser nulo si la relación es opcional (Silberschatz et al., 2020). El propósito de esta regla es prevenir la creación de "registros huérfanos", es decir, registros "hijo" que apunten a una entidad "padre" que ya no existe.
  La criticidad de este concepto se magnifica en el dominio de la salud. Vimalachandran et al. (2018) señalan que "la integridad de los datos en un sistema de expedientes electrónicos es la fuerza motriz del sistema y es un aspecto esencial de la prestación de servicios en todos los niveles". Una falla en la integridad referencial —por ejemplo, una cita agendada para un paciente que ha sido borrado, o una incapacidad firmada por un médico inexistente— comprometería la validez legal y clínica de todo el sistema.
  El mecanismo principal para implementar esta regla es la restricción de clave foránea. Silberschatz et al. (2020) explican que la clave foránea es el mecanismo declarativo a nivel de la base de datos que impone automáticamente esta consistencia, validando cada operación de inserción o actualización. Sin embargo, para las operaciones de borrado, el estándar SQL ofrece diferentes políticas de acción. Las dos más comunes son ON DELETE RESTRICT (o NO ACTION), que rechaza la eliminación de un registro "padre" si algún registro "hijo" todavía lo referencia, y ON DELETE CASCADE, que propaga la eliminación del "padre" a todos los registros "hijo" dependientes (Date, 2003).
  La vinculación con la práctica en el "Sistema Electrónico de Expedientes Clínicos para los Servicios de Salud del H. Ayuntamiento de Progreso" se demuestra en la aplicación de una estrategia diferenciada para estas políticas, basándose en la lógica de negocio de cada entidad:
* Se utilizó ON DELETE RESTRICT en relaciones donde la trazabilidad y la auditoría son imperativas. Por ejemplo, en la relación entre una incapacidad (medical_leaves) y el médico que la emite (doctor_id). Esto asegura que un profesional de la salud no pueda ser eliminado del sistema si existen documentos legales firmados por él, protegiendo el historial de responsabilidad.
* Se utilizó ON DELETE CASCADE en relaciones donde el "hijo" carece de sentido semántico sin el "padre". Por ejemplo, en las relaciones desde patients hacia medical_records, y desde medical_records hacia appointments. En este diseño, el paciente es la entidad raíz. La política de cascada permite que la eliminación de un paciente (en respuesta a un requisito legal como el "derecho al olvido") purgue de forma controlada y completa toda su información asociada (expediente, citas, somatometrías), simplificando el ciclo de vida de los datos y garantizando que no queden registros huérfanos.
2.3. Secuencias Transaccionales
  Un desafío fundamental en los sistemas de bases de datos concurrentes, como un sistema de registros médicos, es la generación de identificadores únicos (folios) de manera eficiente y sin conflictos. Un enfoque ingenuo, como consultar el valor MAX() de un folio y sumarle uno, es propenso a errores de concurrencia y crea cuellos de botella de rendimiento. Para resolver esto, PostgreSQL proporciona un objeto de base de datos atómico llamado SEQUENCE. La documentación oficial lo define como "objetos especiales de una sola fila [...] comúnmente utilizados para generar identificadores únicos para las filas de una tabla" (PostgreSQL Global Development Group, 2025).
  El mecanismo para obtener un valor de una secuencia es la función nextval(). La característica transaccional clave de esta función es que es irreversible; su operación no se revierte (ROLLBACK) aunque la transacción que la invocó falle (PostgreSQL Global Development Group, 2025). Este diseño es una decisión de arquitectura deliberada para garantizar el alto rendimiento y prevenir interbloqueos (deadlocks). Como explica la documentación, para evitar el bloqueo de transacciones concurrentes, el valor obtenido por nextval() no se reclama para su reutilización si la transacción que lo llamó se aborta posteriormente (PostgreSQL Global Development Group, 2025).
  El resultado de este diseño es una compensación fundamental: el sistema sacrifica la "numeración consecutiva sin huecos" a cambio de garantizar la "unicidad y el alto rendimiento" (PostgreSQL Global Development Group, 2025). Para un sistema de alta concurrencia, intentar forzar una numeración sin huecos mediante bloqueos de tabla sería, como lo describe la documentación, "mucho más costoso".
  La vinculación con la práctica es una de las decisiones de arquitectura más importantes en el "Sistema Electrónico de Expedientes Clínicos". Para la generación de folios (record_number en medical_records y folio en medical_leaves), se crearon objetos SEQUENCE dedicados en PostgreSQL (ej. medical_record_number_seq). Al invocar nextval() desde la lógica del modelo (como se vio en el Patrón Observador), el sistema garantiza que dos recepcionistas registrando pacientes simultáneamente nunca recibirán el mismo número de folio. El sistema acepta que, si una transacción de registro falla a la mitad, ese número de folio se "pierde" (creando un "hueco"), pero se prioriza la integridad absoluta de la unicidad del folio y la alta disponibilidad del sistema para el personal del H. Ayuntamiento de Progreso.
3. Lógica de Negocio y Mapeo Objeto-Relacional (ORM)
3.1. Abstracción de la Base de Datos con Eloquent (ORM)
  Una vez establecido un esquema de base de datos relacional normalizado, el siguiente desafío teórico que enfrenta la ingeniería de software es el Desajuste de Impedancia Objeto-Relacional (Object-Relational Impedance Mismatch). Fowler (2012) describe este concepto como el desafío fundamental de sincronizar dos paradigmas distintos: el modelo de datos flexible y orientado a objetos que reside en la memoria de la aplicación, y el modelo relacional rígido, basado en tablas, que reside en la base de datos. La programación orientada a objetos maneja entidades como objetos con herencia y relaciones complejas, mientras que el modelo relacional maneja datos en filas y columnas.
  El Mapeo Objeto-Relacional (ORM) es la técnica de programación que sirve como puente para resolver este desajuste. Existen varios patrones para implementar un ORM; uno de los más influyentes es el patrón Active Record, definido por Fowler (2002). En este patrón, el objeto de dominio mismo encapsula el acceso a la base de datos y la lógica de negocio asociada. Es decir, el objeto "conoce" cómo persistirse (guardarse), actualizarse y eliminarse de la base de datos. Fowler (2002) lo describe como "Un objeto que encapsula una fila en una tabla de base de datos [...], encapsula el acceso a la base de datos y añade lógica de dominio sobre esos datos".
  La vinculación con la práctica en el "Sistema Electrónico de Expedientes Clínicos" se materializa a través de Eloquent ORM, la implementación nativa de Laravel del patrón Active Record (Laravel, s.f.). En lugar de escribir sentencias SQL manualmente, el sistema opera enteramente con objetos. Un registro de la tabla patients se representa como una instancia de la clase Patient. Esta clase no solo contiene los datos (atributos), sino que también encapsula la lógica de persistencia (métodos como ::create() o ->save()) y las relaciones (métodos como ->hasOne(MedicalRecord::class)). Esta abstracción no solo incrementa drásticamente la productividad del desarrollador y la mantenibilidad del código, sino que es una medida de seguridad fundamental. Al utilizar los métodos de Eloquent, el ORM parametriza automáticamente todas las consultas, proporcionando protección nativa contra ataques de Inyección SQL.
3.2. Encapsulación de Reglas de Negocio
  Un pilar fundamental de la Programación Orientada a Objetos (POO) es el principio de encapsulación. Autores canónicos de la ingeniería de software, como Martin (2008), definen este principio como la práctica de ocultar los datos internos y la complejidad de un objeto, exponiendo únicamente una interfaz pública de operaciones que garantizan la integridad de su estado. El objetivo es proteger la consistencia interna del objeto, evitando que código externo pueda corromper sus datos o violar las reglas de negocio.
  El ORM Eloquent implementa este principio teórico mediante mecanismos específicos conocidos como Accesorios (Accessors) y Mutadores (Mutators). La documentación oficial de Laravel (2024) explica que estos permiten a los desarrolladores interceptar el proceso de obtener (get) un atributo o de establecer (set) un atributo. Un Mutador se ejecuta antes de que un valor sea persistido en la base de datos, permitiendo transformar o validar el dato para asegurar su integridad (ej. hashear una contraseña). Un Accessor se ejecuta cuando se lee un atributo del modelo, permitiendo transformar el dato almacenado para su visualización (ej. calcular un valor derivado).
  Una evolución de este principio es la encapsulación de estados finitos mediante Enumeraciones Tipadas (Enums), una característica introducida formalmente en PHP 8.1 (The PHP Group, 2024). En lugar de utilizar "cadenas mágicas" (ej. 'activo', 'pendiente') en la base de datos, un Enum define un conjunto finito y seguro de posibles estados. La documentación de Laravel (2024) detalla cómo el sistema de casting de Eloquent puede convertir automáticamente un valor de la base de datos a un objeto Enum. Esto garantiza en tiempo de ejecución que un modelo solo pueda existir en uno de los estados predefinidos, trasladando la validación de la lógica de negocio al propio tipo de dato.
  La vinculación con la práctica en el "Sistema Electrónico de Expedientes Clínicos" es extensa y se utiliza para reforzar las reglas de negocio directamente en el modelo de datos. Primero, se utilizan Mutadores para garantizar la seguridad, como se observa en la lógica que aplica un algoritmo de hash a la contraseña (password) del personal de salud antes de almacenarla. Segundo, se utilizan Accessors para atributos calculados, destacando el getAgeAttribute en el modelo Patient, que calcula la edad del paciente en tiempo real a partir de su date_of_birth, evitando así el almacenamiento de datos redundantes. Finalmente, el sistema hace un uso intensivo de Enums y Casting para gestionar los flujos de trabajo; clases como PatientType, EmployeeStatus y AppointmentStatus no son simples cadenas de texto, sino Enumeraciones Tipadas que encapsulan las reglas de negocio y aseguran que un expediente o una cita solo puedan existir en un estado válido y conocido por el sistema.
3.3. Trazabilidad y Auditoría
  Un sistema de expedientes clínicos no solo debe gestionar datos, sino también garantizar su integridad, trazabilidad y la capacidad de auditoría a lo largo del tiempo. Los marcos regulatorios que gobiernan la información de salud, como la ley HIPAA en Estados Unidos, exigen mecanismos de auditoría que registren el acceso y la modificación de la información protegida del paciente (U.S. Department of Health and Human Services, 2005). De manera similar, la normativa 21 CFR Parte 11 de la FDA establece que se debe registrar la fecha, hora e identificación del usuario siempre que se creen, modifiquen o eliminen registros electrónicos (FDA, 2003). Estos mecanismos son la base técnica para el principio de no-repudio, el cual, según estándares como ISO/IEC (2022), impide que un usuario pueda negar la autoría de una acción.
  Para cumplir con estos estrictos requisitos de inmutabilidad, se implementó el patrón de borrado lógico (Soft Deletes). A diferencia de un borrado físico (DELETE), que destruye permanentemente la información, el borrado lógico marca un registro como inactivo, generalmente con una marca de tiempo en un campo deleted_at (Taylor et al., 2024). Fowler y Rice (2002) señalan que este patrón es superior en sistemas que requieren cumplimiento de auditoría, ya que preserva el registro histórico completo y permite la reconstrucción del estado del sistema en cualquier punto del tiempo, algo que la eliminación física hace imposible.
  Para completar la pista de auditoría y responder a la pregunta de "quién" realizó una acción, se aplica el patrón conocido como "Sellos de Usuario" (User Stamps o Blameable). Este patrón consiste en registrar automáticamente la identidad del usuario (user_id) que crea o modifica un registro. Como lo describe Stürmer (2010), esta técnica combina sellos de usuario (created_by, updated_by) con marcas temporales (created_at, updated_at) para establecer una pista de auditoría robusta a nivel de fila, vinculando inequívocamente cada cambio a un actor y un momento, proveyendo así una prueba definitiva de las acciones del usuario.
  La vinculación con la práctica en el "Sistema Electrónico de Expedientes Clínicos" es una implementación directa de esta teoría. Primero, se utiliza el trait SoftDeletes de Eloquent en modelos críticos, como MedicalLeave (incapacidades), asegurando que un documento legal nunca sea eliminado físicamente de la base de datos, cumpliendo con los requisitos de inmutabilidad. Segundo, el sistema impone el "Sello de Usuario" en todas las atenciones clínicas; por ejemplo, los modelos SomatometricReading y MedicalLeave requieren un user_id (o doctor_id) que se asigna automáticamente con el ID del profesional autenticado (Auth::id()). La combinación de estas dos técnicas (borrado lógico y sellos de usuario) garantiza que el sistema cumpla con los principios de trazabilidad y no-repudio exigidos en el sector salud.
4. Inteligencia de Negocios (BI) y Visualización de Datos
4.1. El Proceso de BI: De Datos Operativos a KPIs Estratégicos
  La Inteligencia de Negocios (BI) es un concepto que abarca los procesos y tecnologías utilizados para transformar datos crudos en conocimiento accionable que respalde la toma de decisiones. Turban, Sharda y Delen (2020) definen la BI como un proceso sistemático donde los datos operativos se convierten en información estructurada y, posteriormente, en conocimiento que apoya las decisiones tácticas y estratégicas de una organización.
  A nivel de arquitectura de sistemas, este proceso requiere gestionar dos cargas de trabajo fundamentalmente diferentes: OLTP (Online Transaction Processing) y OLAP (Online Analytical Processing). Elmasri y Navathe (2016) explican que los sistemas OLTP están diseñados para la captura de datos del día a día, donde "el énfasis principal... se pone en el procesamiento de consultas muy rápido, [y] el mantenimiento de la integridad de los datos en entornos de acceso múltiple" (p. 923). Por el contrario, Kimball y Ross (2013) definen los sistemas OLAP como aquellos optimizados para "consultas analíticas que típicamente involucran grandes volúmenes de datos y cálculos complejos" (p. 19), diseñados para responder preguntas estratégicas.
  El objetivo de un proceso de BI no es simplemente generar métricas (cualquier medición cuantitativa), sino identificar y monitorear Indicadores Clave de Rendimiento (KPIs). La distinción es crucial: Parmenter (2015) establece que "un indicador clave de rendimiento es una medida vinculada a los objetivos estratégicos de la organización" (p. 12). En el contexto del sector salud, estos objetivos no son la ganancia, sino la eficiencia y la calidad del servicio. Un análisis de indicadores hospitalarios (Assessing hospital performance indicators, 2020) demuestra que los KPIs en salud se miden en dimensiones como la "eficiencia operacional", la "efectividad clínica" y la "centricidad en el paciente".
  La vinculación con la práctica es la arquitectura central del "Sistema Electrónico de Expedientes Clínicos". El Sprint 1 (Digitalización) implementó el componente OLTP del sistema: una base de datos normalizada en PostgreSQL optimizada para la alta concurrencia de transacciones (registrar pacientes, crear citas, guardar incapacidades). El Sprint 2 (BI y Reportes) implementó el componente OLAP, utilizando los datos transaccionales para construir y visualizar KPIs estratégicos relevantes para el H. Ayuntamiento de Progreso. Por ejemplo, en lugar de una simple métrica ("total de citas"), el sistema calcula KPIs como la "tasa de pacientes nuevos vs. recurrentes" (un indicador de cobertura y retención) o el "número de atenciones completadas por médico" (un indicador de eficiencia operacional), proveyendo así el conocimiento accionable que Turban et al. (2020) definen como el objetivo final de la BI.
4.2. Agregación y Procesamiento de Datos
  El proceso de transformar datos transaccionales (OLTP) en información analítica (OLAP) no es conceptual, sino un proceso técnico concreto conocido como agregación. Elmasri y Navathe (2017) definen la agregación como el proceso mediante el cual "grandes volúmenes de datos transaccionales son resumidos en métricas e indicadores clave" (p. 976). Para lograr este resumen, se utilizan dos operaciones fundamentales del lenguaje SQL.
  Primero, la operación JOIN se utiliza para la consolidación de datos. En un esquema OLTP normalizado, la información se encuentra intencionalmente separada en distintas tablas (ej. patients, appointments, users). La operación JOIN "permite combinar información procedente de dos o más tablas [...] haciendo posible la reconstrucción de datos que han sido descompuestos por normalización" (Silberschatz et al., 2020, p. 99). Segundo, la cláusula GROUP BY se utiliza para la summarización (resumen) de esos datos. Como explican Kimball y Ross (2013), esta cláusula, usada con funciones como COUNT o SUM, "es esencial para transformar los datos transaccionales en información sumaria", permitiendo que los analistas obtengan métricas consolidadas segmentadas por distintas dimensiones (p. 50).
  La vinculación con la práctica en el "Sistema Electrónico de Expedientes Clínicos" es directa, ya que estas dos operaciones son el motor técnico detrás de cada gráfica del Sprint 2. Por ejemplo, para generar el KPI "Visitas por Médico", el sistema no lee los datos de forma simple. Primero, ejecuta una operación JOIN entre la tabla appointments y la tabla users (para obtener el nombre del médico). Inmediatamente después, aplica una operación GROUP BY users.name junto con COUNT(*) para resumir miles de filas transaccionales en un conjunto de datos agregado. Como explican Connolly y Begg (2015), es esta sinergia (unir primero, resumir después) la que permite transformar los datos operativos dispersos en los indicadores de rendimiento consolidados que se presentan al personal directivo.
4.3. Visualización de Datos y Exportación 
  El paso final en el proceso de Inteligencia de Negocios es la presentación de los datos agregados al usuario final. La forma en que se presenta esta información es tan importante como la precisión de los datos mismos. La teoría de la visualización de datos, fundamentada por autores como Edward Tufte, argumenta que las gráficas deben maximizar la "proporción de tinta de datos" (data-ink ratio) y eliminar la "basura gráfica" (chartjunk), que se define como elementos visuales que distraen y no aportan a la comprensión de los datos (Tufte, 1983).
  La elección del tipo de gráfica no es arbitraria, sino que responde a principios de codificación visual. Nussbaumer Knaflic (2015) explica que los gráficos de líneas son la elección óptima para comunicar datos de series temporales, ya que el ojo humano sigue la trayectoria de la línea para percibir patrones de cambio y tendencia. Por el contrario, los gráficos de dona o pastel se utilizan para mostrar relaciones de "parte-a-todo" o proporciones, aunque autores como Few (2012) advierten que el cerebro humano es más preciso comparando longitudes (en gráficos de barras) que ángulos (en gráficos de pastel).
  Además de la visualización, un componente crítico del BI moderno es la interoperabilidad de datos, definida por el estándar IEEE (1990) como la capacidad de dos o más sistemas para intercambiar información y utilizarla eficazmente. Esto se logra mediante la exportación a formatos universales como CSV o XLSX. Esta capacidad es la base del BI de Autoservicio (Self-Service BI), un enfoque que, según la investigación académica, empodera a los usuarios no técnicos para crear sus propios análisis e informes sin depender del departamento de TI (Springer, 2023).
  La vinculación con la práctica en el "Sistema Electrónico de Expedientes Clínicos" aplica directamente esta teoría. Primero, la visualización se realiza con ApexCharts, siguiendo los principios de Tufte de gráficas limpias y aplicando la codificación visual correcta: se usan gráficos de líneas (ApexVisitasSemanalesChart) para mostrar tendencias en el tiempo y gráficos de dona (ApexTiposDePacienteChart) para mostrar la composición porcentual. Segundo, la interoperabilidad se implementa con Maatwebsite/excel. Cada página de indicadores incluye una acción de "Exportar", la cual habilita el BI de Autoservicio: el personal directivo del H. Ayuntamiento de Progreso no está limitado a las gráficas predefinidas, sino que puede descargar los datos crudos en formato XLSX para realizar sus propios análisis en Microsoft Excel (ej. tablas dinámicas), logrando la autonomía en la toma de decisiones.
5. Principios de Ciberseguridad y Desarrollo Seguro
5.1. Autenticación y Autorización (Gestión de Roles)
  En el desarrollo de un sistema de expedientes clínicos, la seguridad de la información no es una característica opcional, sino el requisito fundamental sobre el cual se construye todo el sistema. El manejo de Información de Salud Protegida (PHI) exige la implementación de controles estrictos que garanticen la confidencialidad, integridad y disponibilidad de los datos del paciente. El marco de seguridad del sistema se basa en dos conceptos teóricos: Autenticación (determinar quién es un usuario) y Autorización (determinar qué puede hacer ese usuario).
  La Autenticación es el proceso de verificar la identidad declarada de una entidad (NIST, 2017). Para proteger las credenciales del personal de salud, el sistema no almacena contraseñas en texto plano. En su lugar, aplica un algoritmo de hash adaptativo y con "sal" (salt). A diferencia de algoritmos rápidos como MD5, se utiliza bcrypt, un estándar de la industria. Provos y Mazières (1999) fundamentaron la necesidad de algoritmos que, como bcrypt, incorporan un factor de costo computacional configurable. Esto hace que las operaciones sean intencionalmente lentas, volviendo inviables los ataques de fuerza bruta con hardware moderno (Damm, 2017).
  Una vez que un usuario está autenticado, se debe aplicar la Autorización. El modelo teórico estándar para este proceso es el Control de Acceso Basado en Roles (RBAC), definido formalmente por el Instituto Nacional de Estándares y Tecnología (NIST). Ferraiolo y Kuhn (1992) lo definen de la siguiente manera:
  El Control de Acceso Basado en Roles (RBAC) es un método para restringir el acceso al sistema a usuarios autorizados. El acceso se concede basándose en el rol de un usuario en lugar de a través de una autorización explícita usuario por usuario. Con RBAC, una organización puede usar varios roles para diferentes funciones laborales y puede conceder acceso basado en el rol en lugar de en la identidad individual del usuario, simplificando significativamente la administración de la seguridad y reduciendo la posibilidad de conceder accesos inapropiados. (p. 555)
  Este modelo RBAC es el mecanismo técnico para implementar el Principio de Mínimo Privilegio (PoLP), un control de seguridad mandatorio en el sector salud. Estándares como ISO/IEC 27001 (2022) exigen que los derechos de acceso se restrinjan únicamente a los permisos indispensables para las funciones laborales. Esto es un requisito legal de regulaciones como HIPAA, que obliga a las entidades de salud a implementar el estándar de "mínimo necesario" para el acceso a la Información de Salud Protegida (Department of Health and Human Services, 1996).
  La vinculación con la práctica en el "Sistema Electrónico de Expedientes Clínicos" es una implementación directa de esta pila de seguridad. La Autenticación se gestiona mediante el sistema nativo de Laravel, que utiliza bcrypt por defecto. La Autorización implementa el modelo RBAC al asignar roles definidos (ej. Recepcionista, Doctor, Administrador) a cada usuario del H. Ayuntamiento. Finalmente, el Principio de Mínimo Privilegio se impone mediante dos mecanismos distintos, tal como lo describe Stauffer (2019):
1. Middleware (Control de Grano Grueso): Se utiliza para proteger rutas completas. Por ejemplo, un middleware de rol (role:doctor) restringe el acceso a todo el módulo de incapacidades (MedicalLeaveResource) solo a usuarios con ese rol.
2. Policies (Control de Grano Fino): Se utilizan para autorizar acciones específicas sobre modelos de datos. Por ejemplo, una AppointmentPolicy garantiza que un usuario con rol de "Doctor" solo pueda modificar (update) una cita si él mismo es el doctor_id asignado a esa cita, impidiendo que un médico vea o modifique las citas de sus colegas.
5.2. Prevención de Vulnerabilidades Web (OWASP)
  Además de controlar el acceso de los usuarios autenticados, un sistema de software debe defenderse activamente contra ataques técnicos que buscan explotar vulnerabilidades en el código. La autoridad global en esta materia es la Open Web Application Security Project (OWASP), una fundación sin fines de lucro que trabaja para mejorar la seguridad del software. Su publicación más influyente, el OWASP Top 10, es un documento estándar de concienciación que enumera los riesgos de seguridad más críticos para las aplicaciones web. El "Sistema Electrónico de Expedientes Clínicos" mitiga estos riesgos mediante la adopción de un framework moderno que implementa defensas por defecto.
  La vulnerabilidad de Inyección (A03:2021), que incluye la Inyección SQL (SQLi), ocurre cuando "datos no confiables son enviados a un intérprete como parte de un comando o consulta". La contramedida principal es el uso de consultas parametrizadas (prepared statements), que separan la lógica de la consulta de los datos del usuario. La vinculación con la práctica es que el ORM Eloquent de Laravel, utilizado en todo el proyecto, implementa consultas parametrizadas por diseño. El framework "implementa automáticamente prepared statements para todas las consultas, garantizando que los valores de usuario se vinculan de forma segura sin riesgo de inyección SQL".
  La vulnerabilidad de Cross-Site Scripting (XSS) (A07:2021) ocurre cuando "atacantes inyectan scripts maliciosos en campos de entrada que son renderizados en los navegadores de las víctimas". La defensa principal es el escapado automático de salida (output escaping), que convierte caracteres peligrosos (como <script>) en sus entidades HTML inofensivas (como &lt;script&gt;). La vinculación con la práctica reside en el motor de plantillas Blade de Laravel. Como se documenta oficialmente, "las declaraciones {{ }} de Blade se envían automáticamente a través de la función htmlspecialchars() de PHP para prevenir ataques XSS". El proyecto utiliza esta sintaxis por defecto, neutralizando el riesgo de XSS.
  La vulnerabilidad de Cross-Site Request Forgery (CSRF) (A08:2021) es un ataque que "fuerza al navegador del usuario a realizar solicitudes HTTP no autorizadas a una aplicación legítima en la que el usuario está autenticado". La defensa teórica es el Patrón de Token Sincronizador. La vinculación con la práctica es que Laravel "implementa automáticamente protección contra CSRF generando un token único por sesión de usuario", el cual es validado por el middleware VerifyCsrfToken en cada solicitud de modificación de estado (POST, PUT, DELETE). El proyecto implementa esta protección simplemente incluyendo la directiva @csrf en todos sus formularios.
5.3. Lógica de Negocio como Control de Seguridad
  Finalmente, la estrategia de defensa en profundidad del sistema se extiende más allá de los controles técnicos genéricos (como la prevención de XSS) y de los controles de identidad estáticos (RBAC). Una de las amenazas más complejas en la seguridad de aplicaciones son los defectos de lógica de negocio (Business Logic Flaws). A diferencia de las vulnerabilidades de implementación, un defecto de lógica de negocio es el abuso de un flujo de trabajo legítimo de la aplicación para lograr un objetivo no autorizado (Schreuders et al., 2022). Por ejemplo, un usuario que legítimamente puede registrar citas, pero que abusa de esta función para registrar miles de citas y agotar los recursos del sistema.
  La defensa contra estas amenazas requiere un modelo de autorización más dinámico y contextual que el RBAC tradicional. La teoría formal para esto es el Control de Acceso Basado en Atributos (ABAC), definido por el Instituto Nacional de Estándares y Tecnología (NIST). El modelo ABAC es más potente que el RBAC porque no solo considera el rol del usuario, sino que evalúa las reglas de acceso basándose en atributos del sujeto, del objeto, y crucialmente, del entorno. Como lo definen Hu et al. (2014) del NIST:
  ABAC es un modelo de control de acceso lógico que se distingue porque controla el acceso a objetos evaluando reglas contra los atributos de las entidades (sujeto y objeto), las operaciones, y el entorno relevante para una solicitud. [...] ABAC permite un control de acceso preciso, que admite un mayor número de entradas discretas en una decisión de control de acceso... 
  Estos controles se implementan como controles de seguridad a nivel de aplicación, que son reglas personalizadas codificadas directamente en la aplicación y que refuerzan la política de seguridad más allá de lo que ofrece el framework por defecto (NIST, 2020). Nabi y Joseph (2021) explican que la implementación de esta lógica de negocio personalizada es un mecanismo de defensa esencial para prevenir que usuarios autenticados abusen de sus credenciales legítimas fuera de los procesos operativos aprobados.
  La vinculación con la práctica en el "Sistema Electrónico de Expedientes Clínicos" es la implementación de un middleware personalizado: CheckShiftStatus. Este middleware es un control de seguridad a nivel de aplicación que implementa una política ABAC. No solo verifica el rol del usuario (RBAC), sino que evalúa un atributo del entorno: el estado del turno actual de la clínica. Si el turno está "cerrado", el middleware bloquea la solicitud, incluso si el usuario está autenticado y tiene el rol correcto. Este control mitiga directamente un defecto de lógica de negocio, previniendo que un usuario legítimo (o un atacante con credenciales robadas) pueda realizar operaciones en el sistema fuera del horario laboral autorizado por el H. Ayuntamiento de Progreso.
  
  
  

CAPÍTULO II. IDENTIFICACIÓN DE LA PROBLEMÁTICA
Características del área
  El presente proyecto de residencia profesional se desarrolló en el H. Ayuntamiento de Progreso, entidad de la administración pública municipal ubicada en la costa norte del estado de Yucatán, a aproximadamente 35 kilómetros de la capital, Mérida. El municipio de Progreso de Castro se localiza entre las coordenadas 21° 07' y 21° 20' de latitud norte y 89° 29' a 89° 52' de longitud oeste, lo que lo convierte en un punto estratégico dentro de la Región 6, denominada “Influencia Metropolitana”, debido a su estrecha vinculación con la zona metropolitana de Mérida
  De acuerdo con el censo de población y vivienda 2020 del INEGI, el municipio cuenta con una población de 53,958 habitantes, de los cuales más de 41,000 residen en la cabecera municipal. Este crecimiento demográfico le ha otorgado un papel protagónico como centro económico, turístico y logístico de la península de Yucatán.
  Su giro principal es la administración y prestación de servicios públicos, operando enteramente con capital público proveniente de participaciones federales, estatales y recaudación local. La sede del gobierno municipal se ubica en el Palacio Municipal de Progreso, con dirección en Calle 80 No. 150, entre calles 31 y 33, colonia Centro, C.P. 97320, Progreso, Yucatán.
  La relevancia estratégica de Progreso para el estado se sustenta en tres pilares económicos fundamentales:
1. Actividad portuaria y logística. El Puerto de Altura, con un viaducto que se interna 6.5 km en el Golfo de México, ostenta el Guinness World Record como el muelle más largo del mundo. Su infraestructura permite recibir embarcaciones de hasta 10 metros de calado y lo posiciona como nodo logístico clave para el comercio internacional con Estados Unidos, Europa y Asia.
2. Industria pesquera. Progreso es base de una de las industrias pesqueras más importantes de México, aportando más del 50% de la producción nacional de mero y más del 60% de pulpo
  La pesca sustentable se ha vuelto eje central para preservar el ecosistema y asegurar el sustento de la comunidad local.
3. Turismo. Con más de 30 km de litoral, Progreso es un destino turístico de relevancia regional e internacional. Además de ser punto de llegada de cruceros, su cercanía con sitios arqueológicos mayas como Chichén Itzá, Uxmal y Dzibilchaltún amplía su atractivo para visitantes nacionales y extranjeros.
  En términos jurídicos y administrativos, el Ayuntamiento de Progreso se rige por el Artículo 115 de la Constitución Política de los Estados Unidos Mexicanos, que establece al municipio libre como la base de la organización política y administrativa del país. Este marco legal le confiere autonomía política, administrativa y financiera, y le otorga facultades reglamentarias para expedir bandos de policía y gobierno, reglamentos y disposiciones de observancia general.
  El objetivo general del Ayuntamiento es gobernar y administrar los servicios públicos esenciales —agua potable, drenaje, alumbrado, limpia, recolección de residuos, mercados, panteones, rastros, parques y jardines— así como funciones de seguridad pública, tránsito vehicular y planeación urbana. Su estructura está encabezada por el Cabildo, integrado por el Presidente Municipal, regidores y síndicos, elegidos democráticamente por la ciudadanía para periodos de tres años.
  La administración municipal cuenta con más de 1,500 empleados, distribuidos en direcciones y departamentos que atienden los distintos servicios y necesidades de la población. Dentro de esta macroestructura, el presente proyecto de residencia se centra en una necesidad crítica de la Dirección de Salud Municipal, dependencia encargada de coordinar la atención médica primaria en beneficio de la población en situación de vulnerabilidad.
  Antes de la implementación del proyecto, las principales actividades del área se desarrollaban en un esquema manual:
* En recepción, se creaban expedientes en papel para cada paciente.
* En enfermería, se registraban valoraciones somatométricas.
* En consulta general, los médicos agregaban diagnósticos y tratamientos manuscritos.
* Servicios complementarios como nutrición, psicología y odontología generaban registros independientes, lo que ocasionaba fragmentación de la información y falta de trazabilidad clínica.
  Este modelo, además de ineficiente, representaba un riesgo operativo al dificultar la conservación y resguardo seguro de la información médica.
  Formalmente, la residencia se llevó a cabo en la Dirección de Tecnologías de Información y Conectividad (TICs), unidad administrativa que funge como socio estratégico para la modernización del Ayuntamiento. Originalmente concebida como un área de soporte técnico, la Dirección de TICs ha evolucionado hasta convertirse en un catalizador de la transformación digital en el sector público.
  Entre sus funciones destacan:
* La gestión de servidores, redes e infraestructura tecnológica.
* La garantía de la ciberseguridad institucional y la protección de datos sensibles.
* El diseño, desarrollo y mantenimiento de sistemas informáticos.
* La implementación de iniciativas de gobierno digital y servicios en línea.
  Actualmente, la Dirección de TICs enfrenta desafíos significativos como presupuestos limitados, modernización de sistemas obsoletos, resistencia al cambio organizacional y amenazas de ciberseguridad cada vez más sofisticadas
  Sin embargo, sus objetivos estratégicos incluyen promover la interoperabilidad de sistemas, fomentar el gobierno abierto mediante datos accesibles a la ciudadanía y potenciar el uso de Big Data para la toma de decisiones en áreas clave como salud y educación.
  En este contexto, el proyecto “Sistema Electrónico de Expedientes Clinicos para los Servicios de Salud del H. Ayuntamiento de Progreso” surge como un esfuerzo interdepartamental: la Dirección de TICs, en su rol de motor de innovación, asignó al residente profesional para diseñar e implementar una solución tecnológica que atendiera la problemática de la Dirección de Salud.
  La supervisión técnica del proyecto estuvo a cargo del MTI. José Emiliano Tuyín Anguas, en calidad de Consultor en Ciberseguridad, asegurando que cada etapa del desarrollo cumpliera con estándares de seguridad y buenas prácticas institucionales.
  Finalmente, para dar claridad a la estructura organizativa del área anfitriona y la ubicación jerárquica del residente dentro de ella, se incluye el organigrama formal de la Dirección de TICs, donde se visualiza la articulación entre la jefatura de área, el personal técnico especializado y la integración del residente como recurso estratégico para el cumplimiento de los objetivos digitales del Ayuntamiento.
  

Identificación de la problemática
  El principal problema que se busca resolver con este proyecto es la dependencia de un sistema de gestión de expedientes clínicos obsoleto y enteramente manual en la Dirección de Salud Municipal del H. Ayuntamiento de Progreso. Este esquema de trabajo, basado en registros físicos, representa un riesgo operativo considerable y es la causa fundamental de una serie de deficiencias críticas que impactan la calidad del servicio, la seguridad de la información y la eficiencia operativa. Dichas deficiencias se pueden jerarquizar de la siguiente manera:
  En primer lugar, el sistema actual genera graves ineficiencias operativas que afectan directamente los tiempos de atención. La localización de expedientes es un proceso lento e impreciso, dependiendo únicamente de búsquedas manuales por nombre o número correlativo, sin ningún tipo de respaldo digital. Esta situación se agrava por la imposibilidad de que múltiples profesionales —como personal de recepción, enfermería y médicos— consulten un mismo expediente de manera simultánea, lo que ralentiza el flujo de atención y provoca interrupciones constantes y evitables en el servicio.
  Derivado de lo anterior, surge una segunda capa de problemas relacionada con la vulnerabilidad en la seguridad y la confidencialidad de los datos. El modelo físico carece de cualquier mecanismo de trazabilidad que permita saber quién accede o modifica la información clínica. Esta falta de control no solo compromete la confidencialidad de datos personales sensibles, sino que también contraviene directamente los principios de seguridad y transparencia establecidos en la Ley General de Protección de Datos Personales en Posesión de Sujetos Obligados.
  Finalmente, esta fragmentación de la información genera una incapacidad estratégica para la toma de decisiones basada en datos. La generación de estadísticas mensuales, necesarias para la planificación de la salud pública, se realiza de forma aislada en cada área mediante hojas de cálculo desconectadas. Este método es propenso a errores, consume una cantidad significativa de tiempo del personal y dificulta la consolidación de datos confiables, impidiendo la elaboración de indicadores clave para la gestión municipal. En conjunto, este rezago tecnológico no solo compromete la calidad del servicio, sino que afecta directamente el derecho de la ciudadanía a recibir una atención digna, segura y oportuna.
  Para abordar de manera integral la problemática expuesta, se ha estructurado un plan de acción que ataca las deficiencias detectadas de forma secuencial y ordenada. El desarrollo se ha dividido en tres fases principales o sprints, cada uno diseñado para construir una capa de valor sobre la anterior y responder a un objetivo clave del proyecto.
  La primera fase, denominada "Digitalización de expedientes", está diseñada para erradicar el problema fundamental de la gestión manual y la fragmentación de datos. Su objetivo es construir el núcleo funcional del sistema, estableciendo los módulos para el registro centralizado de pacientes y la captura de atenciones clínicas, garantizando así la disponibilidad de la información.
  Posteriormente, la segunda fase, "Implementación de seguridad y control de accesos", se enfoca directamente en mitigar los riesgos operativos y legales asociados a la falta de control. En esta etapa se implementarán los mecanismos de autenticación segura, el control de acceso basado en roles (RBAC) y el cifrado de datos sensibles, robusteciendo la confidencialidad e integridad de la información conforme a las buenas prácticas y normativas vigentes.
  Finalmente, la tercera fase, "Reportes inteligentes y panel administrativo", tiene como propósito transformar los datos operativos en un activo estratégico. A través de la creación de un panel de mando con reportes clínico-demográficos, se dotará al personal directivo de herramientas para el análisis y la toma de decisiones informadas, solucionando así la deficiencia actual en la generación de estadísticas confiables.
Alcances y limitaciones
  Al ser un apartado retrospectivo, voy a postergarlo, así evito la especulación.
Alcances del Proyecto:
* El sistema se desarrollará en un entorno de red local (LAN), sin despliegue web, debido a la naturaleza sensible de la información y las condiciones actuales de infraestructura.
* Permitirá el acceso simultáneo de múltiples usuarios en red local, mediante un sistema de gestión de roles y sesiones activas.
* Estará enfocado exclusivamente en las áreas operativas descritas en el proyecto, correspondientes a los módulos de atención de medicina general, psicología, nutrición y odontología.
* Se desarrollarán únicamente los módulos y funcionalidades definidos en el alcance técnico del proyecto, priorizando la atención, gestión de pacientes y generación de reportes clínico-demográficos.
* El presupuesto asignado contempla una máquina local para el alojamiento inicial de la base de datos, la cual servirá como servidor en la red interna de las oficinas de Salud Municipal.
Limitaciones del Proyecto:
* El desarrollo estará limitado al periodo de la residencia profesional (15 semanas), por lo que no se incluirán módulos complementarios ni funcionalidades avanzadas fuera del alcance inicial.
* La puesta en producción del sistema, incluyendo su alojamiento en servidores institucionales o en internet, dependerá de futuras decisiones administrativas del H. Ayuntamiento de Progreso.
* Por motivos éticos y de confidencialidad, no se utilizarán datos clínicos reales durante el proceso de desarrollo; todas las pruebas funcionales se realizarán con información simulada.
* No se contempla la capacitación directa del personal operativo durante esta etapa; sin embargo, se entregará una guía técnica básica de uso para facilitar su adopción futura.
* El sistema no incluirá procesos de digitalización retrospectiva de expedientes físicos anteriores; su implementación está pensada para comenzar con nuevos registros a partir del momento de su puesta en marcha.

  

CAPÍTULO III. METODOLOGÍA
Procedimiento y descripción de las actividades realizadas
  El desarrollo del proyecto Sistema Electrónico de Expedientes Clínicos para los Servicios de Salud del H. Ayuntamiento de Progreso se ejecutó siguiendo una metodología ágil, estructurada en tres fases o Sprints cronológicos. A continuación, se describen las actividades realizadas en cada fase:
Sprint 1: Digitalización de expedientes
Priorización de historias de usuario para la digitalización de expedientes
  El objetivo de esta actividad inicial fue definir y priorizar el conjunto de funcionalidades mínimas viables (MVP) para el sistema, enfocándose en aquellas indispensables para el registro y la gestión de expedientes médicos.
  El procedimiento comenzó con una fase de inmersión y observación directa del flujo de trabajo en la Dirección de Salud Municipal. Como parte de los recursos humanos utilizados, se contó con la colaboración del personal de recepción y del área médica, quienes permitieron analizar sus procesos cotidianos de registro, búsqueda y manejo de expedientes físicos. A partir de esta observación, se procedió a redactar las historias de usuario siguiendo el formato estándar de desarrollo ágil: "Como <rol>, quiero <acción>, para <beneficio>". Este procedimiento aseguró que cada funcionalidad propuesta estuviera directamente vinculada a una necesidad real del usuario final.
  Como herramientas tecnológicas, se utilizó Jira Software para documentar, gestionar y priorizar cada una de las historias de usuario en un backlog de producto. Esta plataforma permitió organizar las funcionalidades correspondientes a los servicios, estableciendo los criterios de aceptación para cada una. En la Figura 1 se presenta el backlog de historias de usuario prioritarias gestionadas en esta fase.

Figura 1. Product Backlog de historias de usuario del Sprint 1 en Jira.
Desarrollo de la Historia de Usuario SM-1: Estructurar el Núcleo de Datos Clínicos.
Modelado de datos para el registro de pacientes
  El objetivo de esta tarea fue diseñar e implementar la estructura física de la base de datos para almacenar la información de los pacientes. El procedimiento se ejecutó utilizando el sistema de migraciones del framework Laravel, una herramienta que permite un control de versiones declarativo y programático del esquema de la base de datos, garantizando la consistencia y la reproducibilidad del mismo.
  Se partió de la creación de la migración 2025_09_04_000001_create_patients_table.php para definir la estructura de la tabla patients. Una decisión arquitectónica clave fue definir varios campos biográficos como opcionales (nullable). Esta flexibilidad fue diseñada para soportar la creación de "pre-expedientes" a través de la API del sistema, un flujo de trabajo donde un paciente puede ser registrado con datos mínimos desde un sistema externo (como el gestor de turnos) para ser completado posteriormente por el personal de recepción. En la Figura () se presenta el código de la migración que define la estructura completa de la tabla.
  
Figura 2. Estructura de la migración enfocada en los pacientes
  La estructura de la tabla se organizó en grupos lógicos para una mayor claridad, tal como se detalla en la Tabla (), la cual describe el propósito y las restricciones de cada campo.
Tabla 1 
Descripción de los campos de la tabla patients, detallando su nombre, tipo de dato, restricciones y propósito funcional.
CampoTipo de DatoDescripciónRestricciones  Relaciones  idbigIncrementsIdentificador único del registro.Llave Primaria  tutor_idforeignIdClave foránea que vincula al paciente con un tutor.nullable, onDelete('set null')  Datos Biográficos  full_namestringNombre completo del paciente.nullable  date_of_birthdateFecha de nacimiento del paciente.nullable  sexstring(50)Sexo del paciente.nullable  curpstring(18)Clave Única de Registro de Población.nullable, unique  Datos de Contacto  localitystringLocalidad de residencia del paciente.nullable  contact_phonestringNúmero de teléfono de contacto.nullable  addresstextDirección completa del domicilio.nullable  Detalles Adicionales  has_disabilitybooleanIndica si el paciente presenta alguna discapacidad.default(false)  disability_detailstextDescripción de la discapacidad (si aplica).nullable  Estado del Registro  statusstringEstado del expediente (ej. 'active', 'pending_review').default('active')  created_attimestampFecha y hora de creación del registro.Automático  updated_attimestampFecha y hora de la última actualización.Automático    
  Complementando la entidad principal, se definió la estructura para almacenar la información de los tutores legales. Esta tabla, llamada tutors, centraliza los datos de contacto y parentesco, permitiendo que un mismo tutor pueda ser asociado a múltiples pacientes, como en el caso de hermanos, optimizando la integridad de los datos. La Figura () muestra el código de la migración 2025_09_04_000002_create_tutors_table.php utilizada para este fin.
  
Figura 3. Implementación de la migración para la tabla tutors.
  Los campos que componen esta tabla se describen en la Tabla ().
Tabla 2
Esquema de la tabla tutors.
CampoTipo de DatoDescripciónRestricciones  idbigIncrementsIdentificador único del registro.Llave Primaria  full_namestring(255)Nombre completo del tutor.Requerido  relationshipstring(100)Parentesco con el paciente (ej. Padre, Madre).Requerido  phone_numberstring(20)Número de teléfono de contacto del tutor.nullable  addresstextDirección del domicilio del tutor.nullable  created_attimestampFecha y hora de creación del registro.Automático  updated_attimestampFecha y hora de la última actualización.Automático  
Entidad MedicalRecord (Expediente Clínico)
  La entidad MedicalRecord funciona como el contenedor clínico central para cada paciente, estableciendo el vínculo entre la información biográfica de la persona y todas sus interacciones médicas. La arquitectura de esta tabla se diseñó con dos principios clave:
1. Integridad Referencial Estricta: Se define una relación uno a uno con la tabla patients mediante una clave foránea (patient_id) con una restricción unique(). Crucialmente, se utiliza cascadeOnDelete() para asegurar que si un registro de paciente es eliminado, su expediente clínico asociado también lo sea, evitando así datos huérfanos en el sistema.
2. Separación de Datos: Atributos como el tipo de paciente (patient_type) se almacenan en el expediente y no en el modelo Patient. Esta decisión de diseño refleja que la clasificación de un paciente (ej. "Empleado") es una propiedad contextual de su relación con la institución de salud, y no un dato biográfico inmutable de la persona.
  La Figura () muestra el código de la migración que crea la tabla medical_records.

Figura 4. Código de la migración para la entidad MedicalRecord.
  Asimismo, la Tabla () detalla la función de cada uno de sus campos.
Tabla 3
Esquema de la entidad MedicalRecord.
CampoTipo de DatoDescripciónRestricciones  Relación  idbigIncrementsIdentificador único del registro.Llave Primaria  patient_idforeignIdClave foránea que vincula al expediente con un paciente.unique, cascadeOnDelete  Datos del Expediente  record_numberstringFolio único y oficial del expediente (ej. EXP-000001).unique  patient_typestring(100)Clasificación del paciente dentro de la institución.nullable  employee_statusstring(100)Estatus del paciente si es empleado.nullable  Documentación  consent_form_pathstringRuta de almacenamiento del archivo de consentimiento.nullable  created_at / updated_attimestampsMarcas de tiempo automáticas para auditoría.Automático    
Entidad SomatometricReading (Lectura Somatométrica)
  Esta entidad está diseñada para almacenar los registros de signos vitales y mediciones corporales que se toman a un paciente, representando una de las atenciones clínicas más frecuentes.
  La estructura de la tabla somatometric_readings destaca por dos aspectos clave:
1. Trazabilidad Completa: Cada registro está obligatoriamente vinculado a un expediente (medical_record_id) y al profesional que realizó la medición (user_id). Ambas relaciones utilizan cascadeOnDelete para mantener la integridad de la base de datos.
2. Precisión y Flexibilidad: Se eligieron tipos de datos decimal con precisión específica para mediciones como la temperatura, el peso y la altura, garantizando la exactitud de los datos clínicos. Todos los campos de medición son nullable, lo que refleja el escenario real donde no siempre se registran todos los signos vitales en cada visita.
  Para materializar estos principios, la Figura () presenta el código de la migración que implementa la trazabilidad y la precisión de los datos.

Figura 5. Implementación de la migración para somatometric_readings
  Por su parte, la Tabla () ofrece una descripción detallada de su estructura.
  
Tabla 4
Esquema de la entidad SomatometricReading.
CampoTipo de DatoDescripciónRestricciones  Relaciones  idbigIncrementsIdentificador único del registro.Llave Primaria  medical_record_idforeignIdVínculo al expediente del paciente.cascadeOnDelete  user_idforeignIdVínculo al usuario (profesional) que registra.cascadeOnDelete  Signos Vitales  blood_pressure_systolicsmallIntegerPresión arterial sistólica.nullable  blood_pressure_diastolicsmallIntegerPresión arterial diastólica.nullable  heart_ratesmallIntegerFrecuencia cardíaca en ppm.nullable  temperaturedecimal(4, 1)Temperatura corporal en °C.nullable  Medidas Corporales  weightdecimal(5, 2)Peso del paciente en kg.nullable  heightdecimal(5, 2)Altura del paciente en m.nullable  Información Adicional  observationstextObservaciones adicionales del profesional.nullable  created_at / updated_attimestampsMarcas de tiempo para auditoría.Automático  
Entidad MedicalLeave (Incapacidad Médica)
  Esta entidad gestiona la expedición y el seguimiento de las incapacidades médicas, un proceso crítico que requiere alta integridad de datos y trazabilidad. La implementación se centra en la automatización y la seguridad de los registros.
  Las características arquitectónicas más relevantes son:
1. Generación Automática de Folio: Para garantizar un identificador único, secuencial e infalsificable, el sistema genera un folio (INC-AÑO-NÚMERO) automáticamente cada vez que se crea un nuevo registro. Esta lógica, implementada en el evento creating del modelo, utiliza una secuencia de PostgreSQL (medical_leave_folio_seq), asegurando la unicidad incluso en escenarios de alta concurrencia.
2. Trazabilidad del Emisor: El modelo asigna automáticamente el id del médico autenticado (Auth::id()) al crear la incapacidad, asegurando que siempre se conozca al profesional responsable de la expedición.
3. Reglas de Integridad Referencial: La migración establece reglas de borrado diferenciadas: cascadeOnDelete para el expediente (si se borra el expediente, se borran sus incapacidades) y restrictOnDelete para el médico, impidiendo que un usuario profesional sea eliminado del sistema si ha emitido incapacidades, protegiendo así el histórico legal.
4. Borrado Lógico (Soft Deletes): Se implementa el borrado suave para que los registros de incapacidades nunca se eliminen permanentemente de la base de datos, cumpliendo con los requisitos de conservación de datos médicos.
  La materialización de estas reglas de negocio —desde la generación del folio hasta la integridad referencial y el borrado lógico— se establece en la migración de la base de datos, cuyo código se presenta en la Figura ().

Figura 6. Código de la migración para la entidad MedicalLeave.
  Complementariamente, la Tabla () ofrece una descripción detallada del propósito de cada campo en este proceso.
Tabla 5
Descripción de los campos para la tabla medical_leaves.
CampoTipo de DatoDescripciónRestricciones  Identificación  idbigIncrementsIdentificador único del registro.Llave Primaria  foliostringFolio único generado por el sistema.unique  Relaciones  medical_record_idforeignIdVínculo al expediente del paciente.cascadeOnDelete  doctor_idforeignIdVínculo al médico (usuario) que emite.restrictOnDelete  Fechas Clave  issue_datedateFecha de expedición del documento.Requerido  start_datedateFecha de inicio del periodo de incapacidad.Requerido  end_datedateFecha de fin del periodo de incapacidad.Requerido  Detalles Médicos  reasontextDiagnóstico o justificación médica.Requerido  issuing_departmentstringÁrea que emite el documento (ej. Medicina General).nullable  Workflow  statusstringEstado de la incapacidad (ej. pendiente_aprobacion).default(...)  created_at / updated_attimestampsMarcas de tiempo para auditoría.Automático  deleted_attimestampMarca de tiempo para borrado lógico.softDeletes  
Entidad Service (Servicio Médico)
  La entidad Service es fundamental para el funcionamiento del sistema, ya que define el catálogo de atenciones médicas y administrativas que la institución ofrece a los pacientes (ej. "Consulta General", "Psicología", "Nutrición"). Esta tabla no solo nombra los servicios, sino que también almacena sus propiedades operativas.
  Las características principales de esta entidad son:
1. Gestión Operativa: Incluye campos clave para la administración diaria como cost (costo), schedule (horario) y shift (turno), este último gestionado a través de un Enum para estandarizar los valores.
2. Asignación de Responsabilidad: Cada servicio puede tener un responsible_id, que lo vincula a un usuario del sistema (generalmente un jefe de área o coordinador), permitiendo una clara asignación de responsabilidades.
  Para soportar esta funcionalidad, la Tabla () desglosa la estructura de la entidad Service, detallando los campos clave que permiten su gestión operativa y la asignación de responsabilidades.
Tabla 6
Esquema de la entidad Service.
CampoTipo de DatoDescripciónRestricciones  Identificación  idbigIncrementsIdentificador único del registro.Llave Primaria  namestringNombre oficial del servicio.unique  descriptiontextDescripción detallada de lo que incluye el servicio.nullable  Datos Operativos  costdecimal(8, 2)Costo del servicio para el paciente.nullable  departmentstringDepartamento que ofrece el servicio.nullable  schedulestringHorario de atención del servicio.nullable  shiftstringTurno de atención (ej. Matutino, Vespertino).Enum  Gestión y Estado  responsible_idforeignIdVínculo al usuario responsable del servicio.nullable  is_activebooleanIndica si el servicio está actualmente disponible.default(true)  created_at / updated_attimestampsMarcas de tiempo para auditoría.Automático  
Desarrollo de la Historia de Usuario SM-2: Registrar Datos de Pacientes Nuevos
  Para dar inicio al desarrollo del sistema, se abordó la primera historia de usuario, cuyo objetivo era digitalizar el proceso de alta de pacientes. La historia se definió con el siguiente formato:
* Como: Recepcionista
* Puedo: Gestionar el registro de nuevos pacientes con sus datos esenciales.
* Para: Dar de alta a las personas que solicitan atención por primera vez de manera eficiente y centralizada.
  El criterio de aceptación principal fue que, al introducir los datos de un nuevo paciente, el sistema debía crear un expediente electrónico único, validando la Clave Única de Registro de Población (CURP) para evitar duplicados. Para completar esta funcionalidad, se ejecutaron las siguientes tareas técnicas:
Implementación del Recurso de Gestión de Pacientes (CRUD)
  Una vez definida la estructura de datos, el siguiente paso fue construir la interfaz de usuario para la gestión de pacientes (Crear, Leer, Actualizar y Eliminar). Se tomó la decisión arquitectónica de utilizar Filament v4, un constructor de paneles de administración para Laravel. Esta elección permitió abstraer la complejidad del andamiaje de la interfaz y concentrar los esfuerzos de desarrollo en la implementación de la lógica de negocio específica del sistema. Siguiendo las convenciones de Filament v4, la lógica se encapsuló en archivos especializados: PatientResource para la configuración general, PatientTable para la vista de listado y PatientForm para el esquema del formulario.
  El formulario de creación y edición de pacientes se diseñó utilizando una interfaz de pestañas (Tabs) para organizar la gran cantidad de información en secciones lógicas: "Información Personal", "Contacto y Residencia" y "Expediente y Documentos", mejorando así la experiencia del usuario final. "Para ilustrar cómo esta estructura se traduce en una mejor experiencia de usuario, la Figura () muestra la interfaz del formulario, donde la disposición en pestañas simplifica visualmente la entrada de datos.

Figura 7. Interfaz de creación y edición de pacientes.
Deduplicación y Autocompletado de Datos mediante CURP
  Para garantizar la integridad de los datos y agilizar el proceso de registro, se implementó una robusta lógica de validación y autocompletado en el campo de la Clave Única de Registro de Población (CURP). Este mecanismo opera en múltiples capas:
1. Experiencia de Usuario (Frontend): Se aplicó una máscara (x-mask) para guiar al usuario en el formato correcto y una directiva de AlpineJS para convertir la entrada a mayúsculas en tiempo real.
2. Validación de Integridad: Se utilizó la regla ->unique() de Filament para asegurar que no existan CURPs duplicadas en la base de datos y una expresión regular (->regex()) para validar la estructura formal de la clave.
3. Lógica Reactiva para Autocompletado: Mediante el método ->live() y el hook ->afterStateUpdated(), el formulario reacciona instantáneamente cuando se introduce una CURP de 18 caracteres. El sistema extrae la fecha de nacimiento y el sexo del paciente a partir de la clave y rellena automáticamente los campos correspondientes, minimizando los errores de captura manual y mejorando la eficiencia del personal de recepción.
  La orquestación de estas capas —desde la máscara de entrada hasta la validación y el autocompletado reactivo— se implementa de manera declarativa en el PatientForm.php, cuyo código se presenta en la Figura ().

Figura 8. Implementación de la lógica para el campo CURP.
Formularios Condicionales para Lógica de Negocio
  Para manejar las reglas de negocio específicas del sistema, el formulario se construyó con componentes condicionales que se muestran u ocultan dinámicamente según las selecciones del usuario. La implementación se basó en el método ->visible() de Filament, que evalúa el estado de otros campos para decidir la renderización de una sección.
  Un ejemplo clave de esta funcionalidad es la gestión de pacientes pediátricos. La sección para asignar un tutor legal solo se hace visible si el campo "Tipo de Paciente" tiene el valor Pediátrico. Adicionalmente, para optimizar el flujo de trabajo, el campo de selección de tutor incluye la funcionalidad de creación "inline" (->createOptionForm()), que permite al recepcionista registrar un nuevo tutor en una ventana modal sin necesidad de abandonar el formulario de creación del paciente. Mientras que la Figura () demuestra este flujo de trabajo dinámico desde la perspectiva del usuario final, la Figura () detalla el código declarativo que lo hace posible. 

Figura 9. Interfaz condicional para la gestión de pacientes pediátricos.

Figura 10. Código que traduce las reglas de negocio en comportamiento de la interfaz.
Generación Automática de Expediente y Número de Folio
  Un requisito fundamental del sistema es la asignación de un número de expediente único, consecutivo e infalsificable a cada nuevo paciente. En lugar de una simple auto-numeración en la tabla de pacientes, se implementó una arquitectura más robusta separando dos conceptos: la entidad biográfica (Patient) y la entidad clínica (MedicalRecord).
  Para clarificar la elegante arquitectura que gestiona la creación del expediente médico y su folio único, la Figura () presenta un diagrama de flujo que ilustra la secuencia de eventos. A continuación, se detallan estos dos pasos esenciales:

Figura 11. Diagrama de flujo del proceso de creación de expedientes.
* Creación del Contenedor Clínico: Inmediatamente después de que un nuevo registro de Patient es guardado en la base de datos, se dispara el evento static::created(). Este evento tiene la única responsabilidad de crear un MedicalRecord asociado, estableciendo la relación uno a uno entre el paciente y su expediente. La implementación de este primer paso, que vincula al paciente con su contenedor clínico, se puede observar en el código del evento static::created() presentado en la Figura ().

Figura 12. Código del evento static::created() en el modelo Patient
* Asignación del Folio Único: Justo antes de que el nuevo MedicalRecord sea guardado, se dispara el evento static::creating(). Este es el punto donde se genera el número de expediente. Para asegurar la unicidad y evitar condiciones de carrera, la lógica no se basa en el id de la tabla, sino que consulta directamente una secuencia de PostgreSQL (medical_record_number_seq). Este mecanismo de base de datos garantiza la generación de un número consecutivo único que luego es formateado (EXP-000001) y asignado al campo record_number. El código que implementa esta lógica de generación segura, utilizando la secuencia de PostgreSQL para garantizar la unicidad, se detalla en la Figura ().
  
Figura 13. Lógica de generación de folio en el evento static::creating() del modelo MedicalRecord.
Visualización y Gestión de la Lista de Pacientes
  Para completar el ciclo de gestión, se implementó una interfaz de listado que no solo presenta los datos, sino que también ofrece herramientas de búsqueda, filtrado y personalización. La lógica se dividió en dos archivos clave: PatientTable.php, que define la estructura y contenido de la tabla, y ListPatients.php, que enriquece la página con una capa de navegación por pestañas para el filtrado rápido.
Configuración de la Tabla de Datos
  La estructura de la tabla se definió en el archivo PatientTable.php. En lugar de una simple lista de texto, cada columna fue configurada para maximizar la claridad y la usabilidad, implementando varias características clave:
* Visualización Enriquecida: Se utilizaron componentes visuales como insignias (->badge()) con colores condicionales para campos como el sexo y el estatus, permitiendo una identificación rápida del estado de cada registro.
* Presentación de Datos Relacionados: Se empleó la notación de punto para acceder y mostrar datos de modelos relacionados directamente en la tabla, como el número de expediente (medicalRecord.record_number) y el nombre del tutor, el cual se muestra inteligentemente en la descripción del nombre del paciente.
* Interactividad del Usuario: Se incorporaron funcionalidades que mejoran la experiencia del usuario, como la capacidad de copiar datos al portapapeles (->copyable()) para campos como la CURP y el teléfono, y columnas ocultables (->toggleable()) que permiten al personal personalizar la vista según sus necesidades.
  El resultado de estas configuraciones es una interfaz de datos que prioriza la legibilidad y la eficiencia del usuario, como se demuestra en la Figura (), la cual ilustra la implementación de insignias, datos relacionales y controles interactivos en una vista unificada.

Figura 14. Tabla de gestión de pacientes con visualización enriquecida.
Filtrado Dinámico mediante Pestañas
  Para facilitar la segmentación de la base de pacientes, la página de listado (ListPatients.php) fue mejorada con un sistema de pestañas de filtrado dinámico. Este sistema se genera programáticamente a partir de las definiciones en el Enum PatientType.
  El método getTabs() itera sobre cada caso del Enum y crea una pestaña (Tab) para cada tipo de paciente (Externo, Empleado, Pediátrico, etc.). Cada pestaña se configura con un ícono, un color distintivo y una insignia que muestra el número total de pacientes en esa categoría. La funcionalidad principal reside en el método ->modifyQueryUsing(), que altera la consulta a la base de datos para cada pestaña, filtrando eficazmente la tabla para mostrar únicamente los registros que coinciden con el tipo o estatus seleccionado. Este enfoque crea una experiencia de navegación fluida y potente, convirtiendo una simple tabla en un panel de control interactivo. La implementación de este enfoque transforma la tabla de datos en un panel de control interactivo, como se demuestra en la interfaz de la Figura (), donde se aprecian las pestañas de filtrado en funcionamiento.

Figura 15. Pestañas de filtrado dinámico en el listado de pacientes.
Visualización Detallada y Registro de Atenciones
  Para la visualización de la ficha completa de un paciente, se adoptó una estrategia de reutilización de componentes para maximizar la consistencia y minimizar la duplicación de código. En lugar de construir una vista desde cero, se configuró la "Infolist" (la vista de detalles de Filament) para que utilizara el mismo esquema definido en PatientForm.php, pero renderizando los campos como texto no editable. Esta conexión se establece de manera concisa en el archivo PatientResource.php. Esta transformación de una simple vista de datos en un punto de acción central se demuestra visualmente en la Figura (), la cual muestra la ficha del paciente con la acción de registro disponible.

Figura 16. Reutilización de componentes para la vista de detalles.
  Sin embargo, la página de visualización (ViewPatient.php) se potenció para que funcionara como un punto central de acciones clínicas. Se añadió un botón "Editar Paciente" y, de manera más significativa, una acción personalizada para "Registrar Somatometría". Esta funcionalidad permite al personal de salud, como enfermeros, añadir nuevas lecturas de signos vitales a través de una ventana modal sin abandonar la ficha del paciente.
  La acción define su propio formulario, organizado en secciones para presión arterial, signos vitales y medidas corporales. Al guardar, la lógica asocia automáticamente la lectura con el paciente que se está visualizando ($this->getRecord()) y con el profesional que ha iniciado sesión (Auth::id()), garantizando la trazabilidad completa de los datos. El código que encapsula esta lógica —desde la definición del formulario modal hasta la asignación automática de datos para garantizar la trazabilidad— se detalla en la implementación de la acción de la Figura ()

Figura 17. Implementación de la acción personalizada "Registrar Somatometría".
  El resultado es una interfaz que no solo muestra información, sino que invita a la acción, optimizando el flujo de trabajo clínico al permitir el registro de datos contextuales de manera inmediata. Esta transformación de una simple vista de datos en un punto de acción central se demuestra visualmente en la Figura (), la cual muestra la ficha del paciente con la acción de registro disponible.

Figura 18. Ficha del paciente como punto central de acciones clínicas.
Edición y Automatización de Flujos de Trabajo
  La funcionalidad para modificar los datos de un paciente se implementó en la página EditPatient.php. Para mantener la consistencia visual y funcional, esta interfaz reutiliza el mismo esquema del formulario de creación (PatientForm.php), presentando al usuario un entorno familiar. La cabecera de la página incluye las acciones estándar para ver o eliminar el registro (ViewAction, DeleteAction), completando así el ciclo de operaciones CRUD (Crear, Leer, Actualizar, Eliminar).
  Más allá de la edición estándar, esta sección incorpora dos automatizaciones de flujo de trabajo diseñadas para mejorar la eficiencia y la experiencia del usuario.
1. Activación Automática de Expedientes: Para gestionar el flujo de "pre-expedientes" creados por la API (con estatus pending_review), se implementó una lógica en el método mutateFormDataBeforeSave. Este método intercepta los datos justo antes de guardarlos. Si detecta que el expediente está en estado pendiente, lo cambia automáticamente a active y envía una notificación de éxito al usuario. Esta automatización elimina un paso manual para el personal de recepción y asegura que ningún expediente quede en un estado intermedio una vez completado. El código que habilita esta automatización, utilizando el hook mutateFormDataBeforeSave para intervenir de forma proactiva en el ciclo de vida de los datos, se detalla en la Figura ().
  
Figura 19. Automatización del flujo de trabajo en la edición de pacientes.
2. Redirección Contextual Inteligente: Para crear una navegación fluida entre diferentes módulos del sistema, se desarrolló un mecanismo de redirección inteligente. Mediante el método getRedirectUrl, el sistema puede determinar el contexto original del usuario a través de un parámetro en la URL. Si un usuario es enviado a editar un paciente desde una cita específica, al guardar los cambios, el sistema lo devuelve directamente a la página de esa cita, en lugar de a la lista general de pacientes. Esto evita interrupciones en el flujo de trabajo del personal médico y administrativo. El mecanismo que implementa esta navegación fluida, utilizando el método getRedirectUrl para preservar el contexto del usuario y evitar interrupciones, se muestra en el código de la Figura ().
  
Figura 20. Redirección contextual inteligente. 
  Con estas funcionalidades, el módulo de gestión de pacientes trasciende un simple CRUD para convertirse en una herramienta de software con procesos automatizados y flujos de trabajo optimizados que responden a las necesidades operativas de la Dirección de Salud.
Desarrollo de la Historia de Usuario SM-3: Implementar la Gestión de Citas
  Esta historia de usuario se centra en el desarrollo del recurso Appointment, el cual gestiona el agendamiento y seguimiento de las visitas de los pacientes. Esta entidad es el eje central del flujo operativo, ya que conecta al paciente (a través de su MedicalRecord), el Service que se le proporcionará y el doctor que lo atenderá.
Entidad Appointment (Cita o Visita)
  El modelo Appointment está diseñado para ser flexible y acomodar diferentes escenarios de atención. Su característica más destacada es un sistema dual para la gestión de turnos:
1. Turnos Externos: El sistema puede recibir un ticket_number de una fuente externa, como un sistema de gestión de filas, integrándose con otros procesos de la institución.
2. Turnos Locales (Walk-in): Si un paciente llega sin un turno pre-asignado, el modelo Appointment lo detecta en el evento creating. En este caso, invoca un método interno (generateWalkInTicket) para generar automáticamente un folio local con el formato LOCAL-AÑO-CONSECUTIVO. Este consecutivo se reinicia diariamente, asegurando un sistema de turnos ordenado para los pacientes que se registran en el sitio.
  Esta lógica garantiza que cada cita tenga un identificador único, ya sea externo o generado localmente, lo cual es fundamental para la trazabilidad.
  La migración de la tabla appointments define reglas de borrado específicas para mantener la integridad de los datos. Notablemente, la relación con el médico (doctor_id) utiliza nullOnDelete, lo que permite que una cita se pueda crear sin un médico asignado y que el registro histórico de la cita se conserve incluso si el médico es eliminado del sistema.
  La base técnica que soporta este sistema de turnos flexible y las reglas de integridad de datos se establece en la migración de la Figura (). Por su parte, la Tabla () desglosa la estructura que lo hace posible.

Figura 21. Código de la migración para la entidad Appointment..
Tabla 7
Esquema de la entidad Appointment.
CampoTipo de DatoDescripciónRestricciones  Relaciones  idbigIncrementsIdentificador único del registro.Llave Primaria  medical_record_idforeignIdVínculo al expediente del paciente.cascadeOnDelete  service_idforeignIdVínculo al servicio solicitado.cascadeOnDelete  doctor_idforeignIdVínculo al médico que atiende la cita.nullable, nullOnDelete  Datos de la Visita  ticket_numberstringFolio del turno, ya sea externo o local.unique  shiftstring(50)Turno de la cita (ej. Matutino).nullable  visit_typestring(50)Tipo de visita (ej. Primera Vez, Subsecuente).nullable  clinic_room_numberstringConsultorio asignado para la cita.nullable  reason_for_visittextMotivo principal de la consulta.Requerido  notestextAnotaciones adicionales del personal.nullable  statusstringEstado de la cita (ej. pending, completed).default('pending')  created_at / updated_attimestampsMarcas de tiempo para auditoría.Automático  
Implementación del Formulario de Citas
  El formulario para la creación y edición de citas (AppointmentForm.php) fue diseñado como el centro neurálgico del flujo de trabajo clínico. Su principal objetivo es permitir un agendamiento eficiente, ya sea para pacientes existentes o para pacientes nuevos que se presentan por primera vez.
  
Selección Reactiva y Alta Rápida de Pacientes
La funcionalidad clave del formulario reside en el campo de selección del Expediente Médico. Este componente implementa un flujo de trabajo dual:
1. Selección de Paciente Existente: El usuario puede buscar un paciente por su número de expediente o nombre. Gracias a la reactividad (->live()), una vez que se selecciona un expediente, el método ->afterStateUpdated() se dispara instantáneamente. Este ejecuta una consulta para obtener los datos del paciente asociado y rellena automáticamente una sección de solo lectura con el nombre, la edad y el sexo del paciente. Esto proporciona una confirmación visual inmediata al recepcionista, asegurando que se está agendando la cita para la persona correcta. Para clarificar la secuencia de eventos que se desencadena tras la selección del usuario, la Figura () presenta un diagrama de flujo de esta lógica reactiva.

Figura 22. Diagrama de flujo de la lógica reactiva para la selección de pacientes.
Esta interacción fluida, que valida la selección del paciente en tiempo real, se implementa en el código reactivo presentado en la Figura ().

Figura 23. Lógica reactiva para la confirmación de paciente.
2. Alta Rápida de Paciente Nuevo (Flujo "Walk-in"): Si un paciente no tiene un expediente previo, el personal no necesita abandonar el formulario de citas. Se ha implementado la funcionalidad de "alta rápida" mediante el método ->createOptionForm(). Esto abre una ventana modal que reutiliza el PatientForm completo que ya documentamos. El recepcionista puede dar de alta al nuevo paciente, incluyendo su tutor si es pediátrico, y al guardar, el sistema crea el Patient, su MedicalRecord asociado, y lo selecciona automáticamente en el formulario de la cita. Este patrón de reutilización de esquemas no solo ahorra tiempo de desarrollo, sino que garantiza una experiencia de usuario consistente y un flujo de trabajo ininterrumpido.
  El resultado de este primer flujo de trabajo —la selección de un paciente existente— se ilustra en la Figura (), donde la interfaz muestra los datos del paciente autocompletados para su verificación.

Figura 24. Interfaz de agendamiento con confirmación visual.
El resto del formulario contiene los campos estándar para definir los detalles de la cita, como el servicio a recibir, el médico asignado, el motivo de la visita y su estado inicial, que por defecto es "pendiente".
Implementación de la Tabla de Citas
  La visualización de la lista de citas se define en AppointmentsTable.php. La tabla fue diseñada para funcionar como un panel de control dinámico, proporcionando al personal una visión clara y accionable del estado de las visitas.
Visualización Enriquecida y Columnas Contextuales
  Para maximizar la cantidad de información útil presentada, las columnas de la tabla fueron configuradas con formato enriquecido:
* Presentación Jerárquica: La columna principal muestra el nombre del paciente en un tamaño y peso de fuente mayor, utilizando el campo de descripción para añadir contexto clave como el número de ticket.
* Visualización de Estado: La columna status es la más representativa. Utiliza una combinación de formatStateUsing para mostrar etiquetas amigables (ej. 'pending' se convierte en 'Revisión'), un badge() con colores condicionales para una rápida identificación visual, y un icon() que refuerza el significado del estado.
* Datos Relacionales: La tabla accede a información de modelos relacionados para mostrar datos como el nombre del servicio y el médico asignado, permitiendo búsquedas y ordenamiento sobre estos campos.
Acciones Contextuales y Flujos de Trabajo
  La característica más potente de la tabla es su sistema de acciones dinámicas (recordActions), que presenta al usuario únicamente las opciones relevantes según el estado de la cita y del paciente:
* Flujo de Expediente Incompleto: Si una cita corresponde a un paciente cuyo expediente está en pending_review, aparece una acción especial: "Completar Expediente". Esta acción dirige al usuario directamente al formulario de edición del paciente y, gracias a la lógica de redirección inteligente que ya documentamos, lo devuelve a la lista de citas una vez que el expediente es activado.
* Gestión del Ciclo de Vida de la Cita: Acciones como "Confirmar Asistencia" o "Cancelar Cita" están visibles condicionalmente. Estas permiten al personal modificar el estado de la cita directamente desde la tabla, con una ventana de confirmación para evitar errores. El sistema provee retroalimentación inmediata al usuario a través de una notificación de éxito o advertencia.
  La implementación de estas acciones, que traducen la lógica de negocio en controles de interfaz interactivos, se detalla en el código de la Figura (), mientras que el resultado final en la tabla de citas se puede apreciar en la Figura ().

Figura 25. Implementación de acciones condicionales en la tabla de citas.
  
Figura 26. Interfaz de la tabla de citas con acciones contextuales.
  
Desarrollo de la Historia de Usuario SM-4: Habilitar el Alta Rápida de Pacientes desde el Módulo de Citas
  Uno de los flujos de trabajo más críticos identificados durante el análisis fue el registro de pacientes nuevos que se presentan directamente a solicitar una cita ("walk-in"). Para optimizar este proceso y evitar que el personal de recepción tenga que cambiar de módulo o pantalla, se implementó una funcionalidad de "alta rápida" directamente en el formulario de creación de citas.
  Flujo de Trabajo de Alta Rápida
  Cuando un recepcionista necesita agendar una cita para un paciente que no se encuentra en la base de datos, puede hacer clic en la opción "Crear" dentro del mismo campo de selección de expedientes. Esta acción desencadena el siguiente proceso automatizado:
1. Apertura de Modal: El sistema abre una ventana modal que contiene el formulario completo de creación de pacientes, reutilizando el PatientForm para mantener la consistencia.
2. Registro de Datos: El personal captura toda la información necesaria del paciente, incluyendo datos del tutor si es un caso pediátrico.
3. Creación en Cascada: Al guardar, la lógica createOptionUsing se encarga de:
o Crear el nuevo registro Patient.
o Disparar el evento que crea automáticamente el MedicalRecord asociado.
o Actualizar el MedicalRecord con el tipo de paciente seleccionado en el formulario modal.
4. Autoselección: Una vez creado, el sistema cierra la ventana modal y selecciona automáticamente el expediente del nuevo paciente en el formulario de la cita, precargando sus datos (nombre, edad, sexo) para que el personal pueda continuar con el agendamiento sin interrupciones.
  Esta implementación reduce significativamente el tiempo de registro, minimiza la fricción en el flujo de trabajo y mejora la experiencia del usuario.
  Para ilustrar de manera clara la secuencia de interacciones entre el usuario, el formulario de citas y la lógica de creación de pacientes, la Figura () presenta un diagrama de secuencia de este flujo de trabajo automatizado.
  
Figura 27. Diagrama de secuencia del flujo de alta rápida de pacientes.
  
Desarrollo de la Historia de Usuario SM-5: Registrar Atenciones Clínicas Iniciales (Somatometría)
  Esta historia de usuario se enfoca en proporcionar al personal de salud, principalmente de enfermería, la capacidad de registrar y consultar las mediciones de signos vitales y somatometría de un paciente.
Estructura de Datos
  La base para esta funcionalidad es la entidad SomatometricReading. La migración de su tabla establece relaciones clave con el expediente (medical_record_id), el usuario que registra (user_id) y, de manera opcional, con una cita específica (appointment_id). El uso de cascadeOnDelete en estas relaciones asegura que las lecturas se eliminen automáticamente si el registro principal (expediente, usuario o cita) es borrado, manteniendo así la integridad de la base de datos. La mayoría de los campos de medición son nullable, permitiendo registros parciales que se adaptan a la realidad clínica.
Funcionalidad de Registro: Flujos de Trabajo
  El sistema ofrece dos vías para registrar una lectura somatométrica, cada una diseñada para un contexto operativo diferente:
1. Registro desde la Ficha del Paciente: En la página de ViewPatient, un botón "Registrar Somatometría" abre un formulario modal. Este flujo está pensado para registros generales o de seguimiento que no están necesariamente ligados a una cita formal. La lógica de la acción asocia la nueva lectura con el medicalRecord del paciente en vista y con el user_id del profesional autenticado. 
2. Registro desde la Lista de Citas: En la tabla de AppointmentsTable, cada cita tiene una acción "Registrar Hoja Diaria". Este flujo es más específico y está diseñado para registrar los signos vitales tomados durante una consulta particular. Al crearse, la lectura queda vinculada no solo al expediente y al usuario, sino también al appointment_id, proporcionando una trazabilidad completa del evento clínico.
Visualización del Historial Clínico
  Para evitar sobrecargar la ficha del paciente, la consulta del historial de somatometrías se centraliza en la vista del Expediente Médico (MedicalRecordResource). La implementación se realiza a través de un SomatometricReadingsRelationManager, que presenta una tabla dedicada con todas las lecturas registradas para ese expediente.
       Esta tabla está optimizada para la lectura clínica, con columnas que combinan datos (ej. "sistólica/diastólica mmHg"), añaden sufijos de unidades (kg, m) y muestran el nombre del profesional que realizó cada registro. Esta solución, que centraliza la consulta del historial en una vista optimizada para el personal clínico, se puede apreciar en la interfaz del gestor de relaciones de la Figura ().
  
Figura 28. Gestor de historial de somatometrías
Desarrollo de la Historia de Usuario SM-6: Gestionar el Expediente y Atenciones por Servicio
  Esta historia de usuario representa la culminación del esfuerzo de digitalización: la capacidad del sistema para presentar una visión unificada de 360 grados del paciente y todas sus interacciones clínicas. No se trata de una única pantalla, sino de la arquitectura cohesiva de los Resources que trabajan en conjunto para proporcionar esta visión integral.
El Expediente Clínico como Eje Central
  El sistema se diseñó en torno a la separación de la identidad del paciente (PatientResource) y su historial clínico (MedicalRecordResource). Esta arquitectura permite que la gestión se divida lógicamente:
1. PatientResource: Funciona como el centro para la información biográfica y administrativa. Desde aquí se gestionan los datos personales, de contacto y del tutor. Su vista de detalles (ViewPatient) actúa como un "centro de acciones rápidas", permitiendo al personal iniciar procesos clínicos como el registro de somatometría.
2. MedicalRecordResource: Funciona como el historial clínico oficial. Es aquí donde se centraliza la visualización de todas las atenciones médicas. Utilizando RelationManagers, esta vista presenta de forma ordenada y cronológica el historial de citas, las lecturas somatométricas, las incapacidades emitidas y cualquier otra atención registrada.
  Este diseño permite que un médico o enfermero pueda, con solo dos clics, pasar de la lista general de pacientes a consultar el historial detallado de signos vitales de una persona, logrando el objetivo principal de tener información clínica centralizada, accesible y fácil de gestionar. La Figura () esquematiza esta interacción entre los componentes.

Figura 29. Arquitectura de la visión 360° del paciente.
  
Sprint 2: Reportes y Business Intelligence (BI)
Priorización de historias de usuario para reportes y BI
  El objetivo de esta actividad inicial fue definir y priorizar el conjunto de funcionalidades de Business Intelligence (BI) y reportería para el sistema. El enfoque se centró en transformar los datos operativos, acumulados durante la digitalización de expedientes, en información estratégica que apoye la toma de decisiones de la Dirección de Salud Municipal.
  El procedimiento comenzó con una fase de análisis de requerimientos en colaboración con el personal directivo y administrativo. Se buscaron identificar los indicadores clave de rendimiento (KPIs) y las métricas más relevantes para la gestión de los servicios de salud, como el volumen de pacientes atendidos, la distribución demográfica, la productividad por servicio, entre otros. A partir de este análisis, se procedió a redactar las historias de usuario siguiendo el formato estándar de desarrollo ágil: "Como <rol>, quiero <acción>, para <beneficio>". Este procedimiento aseguró que cada reporte o gráfica propuesta estuviera directamente vinculada a una necesidad real de gestión.
  Como herramientas tecnológicas, se utilizó Jira Software para documentar, gestionar y priorizar cada una de las historias de usuario en un backlog de producto. Esta plataforma permitió organizar las funcionalidades de BI, estableciendo los criterios de aceptación para cada una.
Desarrollo de la Historia de Usuario SM-7: Monitorear la Actividad Diaria en Tiempo Real
  Para satisfacer la necesidad de una visión operativa inmediata, se desarrolló el Panel de Recepción. Este panel está diseñado para ser la pantalla principal del personal de primera línea, ofreciendo una vista en vivo del flujo de pacientes.
Widget de Últimas Visitas
  El componente central de este dashboard es el widget UltimasVisitas, implementado como un TableWidget de Filament. Su función es presentar una tabla de las citas más recientes con una actualización automática cada cinco segundos (poll('5s')), asegurando que la información mostrada sea siempre actual.
  La tabla está configurada para mostrar las columnas más relevantes para la operación diaria, como el nombre del paciente, el servicio solicitado y, crucialmente, el estado de la cita, que se visualiza con insignias de colores e íconos para una rápida interpretación. Además, se incluyen filtros predefinidos que permiten al personal cambiar la vista con un solo clic para ver las citas de "Hoy", las de los "Últimos 30 minutos" o filtrar únicamente por "Pendientes" o "En progreso".
  Esta herramienta proporciona al personal de recepción un control total sobre la actividad del día, permitiéndoles gestionar el flujo de pacientes de manera proactiva. Esta herramienta, que dota al personal de un control proactivo sobre la actividad del día, se materializa en la interfaz del panel de control presentada en la Figura ().
  
Figura 30. Panel de Recepción para monitoreo en tiempo real.
Desarrollo de la Historia de Usuario SM-8: Analizar Indicadores Clave de Rendimiento (KPIs) a través de Gráficas
  Para transformar los datos operativos en conocimiento estratégico, se desarrollaron tres páginas de indicadores dedicadas a Visitas, Servicios y Pacientes. Cada una de estas páginas funciona como un dashboard temático, presentando una colección de gráficas interactivas que visualizan los KPIs más relevantes para la gestión.
  La tecnología central para estas visualizaciones es el plugin Filament Apex Charts, que permite la creación de gráficas ricas e interactivas (barras, donas, áreas, etc.) directamente dentro del ecosistema de Filament. Cada gráfica se implementa como un Widget independiente, permitiendo su reutilización y configuración modular.
Análisis del Estado General de las Visitas
  La primera y más fundamental de las visualizaciones es la gráfica ApexEstadoVisitasChart, ubicada en la página de "Indicadores — Visitas".
* Propósito: Su objetivo es ofrecer una visión macro e instantánea del estado de todas las citas registradas en el sistema.
* Implementación: Se presenta como un gráfico de barras que muestra el conteo total de citas agrupadas por su estado: "Pendiente", "En Progreso", "Completada" y "Cancelada". El widget incluye un filtro que permite al usuario cambiar el rango de tiempo de la consulta ("Hoy", "Esta Semana", "Este Mes", "Todo"), recalculando y actualizando la gráfica dinámicamente.
  Esta herramienta permite a los directivos responder rápidamente a preguntas clave como "¿Cuántas citas se completaron este mes?" o "¿Cuál es nuestro volumen actual de citas canceladas?", facilitando la identificación de patrones y la evaluación de la eficiencia operativa. Esta herramienta, que permite a los directivos responder rápidamente a preguntas clave sobre la eficiencia operativa mediante una visualización interactiva del estado de las citas por rangos de tiempo, se muestra en la interfaz gráfica de la Figura ().
  
Figura 31. Gráfica de estado general de las visitas.
Análisis de la Tendencia Semanal de Visitas
  Para complementar la visión general del estado de las citas, se implementó la gráfica ApexVisitasSemanalesChart, también ubicada en la página de "Indicadores — Visitas".
* Propósito: Su objetivo es analizar la productividad y el flujo de pacientes a corto plazo, mostrando el número de citas completadas cada día durante un periodo semanal.
* Implementación: Se presenta como un gráfico de área que funciona como una serie temporal. El eje horizontal representa los días de la semana y el eje vertical, el número de citas completadas. El widget incluye un filtro que permite al usuario alternar la vista entre "Esta semana" y la "Semana pasada", facilitando la comparación del rendimiento. Técnicamente, la consulta agrupa las citas por día utilizando funciones específicas de PostgreSQL (created_at::date) y emplea la librería CarbonPeriod para asegurar que todos los días de la semana se muestren en la gráfica, incluso aquellos sin citas, evitando así vacíos en la visualización de la tendencia.
  Esta herramienta es crucial para que los supervisores puedan identificar los días de mayor y menor afluencia, ayudando en la planificación de recursos y la optimización de los horarios del personal. Esta herramienta, crucial para que los supervisores identifiquen los días de mayor afluencia y optimicen la planificación de recursos al mostrar la tendencia diaria de citas completadas con una comparativa semanal, se presenta en la interfaz gráfica de la Figura ().

Figura 32. Gráfica de tendencia semanal de visitas.
Análisis de la Demanda por Servicio
  Para comprender qué servicios son los más utilizados por los pacientes, se desarrolló la gráfica ApexServiciosMasSolicitadosChart, ubicada en la página de "Indicadores — Servicios".
* Propósito: Su objetivo es identificar y visualizar la distribución de la demanda entre los diferentes servicios que ofrece la institución.
* Implementación: Se presenta como un gráfico de dona (donut chart), una variante del gráfico circular ideal para mostrar proporciones. Cada sección de la dona representa un servicio, y su tamaño es proporcional al número de citas solicitadas. El widget incluye un filtro que permite al usuario acotar el análisis a "Esta semana", "Este mes" o "Todo" el histórico, proporcionando una visión tanto a corto como a largo plazo de la demanda. Técnicamente, la consulta agrupa el conteo de citas por el nombre del servicio, excluyendo aquellas que han sido canceladas para reflejar la demanda real.
  Esta visualización es fundamental para la gestión de recursos, ya que permite a los directivos identificar qué servicios tienen mayor carga de trabajo y dónde podría ser necesario asignar más personal o presupuesto. Esta visualización, fundamental para la gestión de recursos al permitir a los directivos identificar qué servicios tienen mayor carga de trabajo mediante un gráfico de dona interactivo que muestra la demanda por periodos, se presenta en la interfaz de la Figura ().

Figura 33. Gráfica de demanda por servicio.
Análisis de Productividad por Médico
  Para evaluar la carga de trabajo y la productividad del personal de salud, se implementó la gráfica ApexVisitasPorMedicoChart, la cual se encuentra en la página de "Indicadores — Servicios".
* Propósito: Su objetivo es cuantificar y comparar el número de citas completadas por cada médico del sistema.
* Implementación: Se presenta como un gráfico de barras donde cada barra representa a un médico y su altura corresponde al total de citas que ha completado. El widget incorpora filtros para analizar la productividad en diferentes rangos de tiempo ("Hoy", "Esta semana", "Este mes"), permitiendo una evaluación tanto diaria como a mediano plazo. Técnicamente, la consulta realiza un join entre las tablas appointments y users para agrupar los conteos por el nombre del médico (users.name).
  Esta herramienta proporciona a los coordinadores una visión clara de la distribución de la carga de trabajo, facilitando la toma de decisiones sobre asignación de pacientes y la identificación de patrones de rendimiento. Esta herramienta, que proporciona a los coordinadores una visión clara de la distribución de la carga de trabajo y facilita la toma de decisiones al comparar el número de citas completadas por cada médico en diferentes rangos de tiempo, se muestra en la interfaz gráfica de la Figura ().
  
Figura 34. Gráfica de productividad por médico.
Análisis de la Composición de Pacientes
  Para entender la distribución de la población atendida, se desarrolló la gráfica ApexTiposDePacienteChart, que se encuentra en la página de "Indicadores — Pacientes".
* Propósito: Su objetivo es visualizar la proporción de cada tipo de paciente (Externo, Empleado, Hijo de Empleado, Pediátrico) dentro del sistema.
* Implementación: Se presenta como un gráfico de dona, donde cada segmento representa un tipo de paciente y su tamaño es proporcional al número total de expedientes en esa categoría. La consulta se realiza sobre el modelo MedicalRecord, agrupando los conteos por el campo patient_type. Se utiliza un mapeo de colores consistente para asegurar que cada tipo de paciente siempre se muestre con el mismo color, facilitando su reconocimiento visual a través de todo el sistema.
  Esta visualización es esencial para la administración, ya que permite comprender rápidamente la composición de la base de pacientes, lo cual influye en la planificación de campañas de salud, la gestión de convenios y la asignación de recursos específicos para cada grupo. Esta visualización, esencial para la administración al permitir comprender la composición de la base de pacientes para la planificación de recursos, mostrando la proporción de cada categoría en un gráfico de dona con colores consistentes, se presenta en la interfaz de la Figura ().

Figura 35. Gráfica de composición de pacientes.
Análisis de la Adquisición y Retención de Pacientes
  La última y una de las visualizaciones más estratégicas del sistema es la gráfica ApexPacientesNuevosVSRecurrentes, ubicada en la página de "Indicadores — Pacientes".
* Propósito: Su objetivo es medir y comparar la afluencia de pacientes nuevos frente a la de pacientes recurrentes, un indicador clave para evaluar el crecimiento, la captación y la fidelidad de la base de usuarios.
* Implementación: Se presenta como un gráfico de barras apiladas. Cada barra representa un periodo de tiempo (día o mes), y está dividida en dos segmentos de colores distintos: uno para las citas de "Primera Vez" y otro para las "Subsecuentes". Esta visualización permite comparar no solo el volumen total de citas, sino también la proporción entre pacientes nuevos y recurrentes en cada periodo. El widget incluye filtros para cambiar la granularidad del análisis ("Esta semana", "Este mes", "Año actual"), permitiendo tanto la supervisión a corto plazo como el análisis de tendencias anuales.
  Esta herramienta es de alto valor estratégico, pues permite a la dirección medir el impacto de campañas de salud (a través de picos en pacientes nuevos) y evaluar la satisfacción y retención de los pacientes existentes (a través de un volumen saludable de visitas subsecuentes). Esta herramienta, de alto valor estratégico al permitir medir el crecimiento y la fidelidad de la base de usuarios comparando la afluencia de pacientes nuevos frente a los recurrentes en un gráfico de barras apiladas con filtros de tiempo, se muestra en la interfaz de la Figura ().

Figura 36. Gráfica de adquisición y retención de pacientes.
  
Desarrollo de la Historia de Usuario SM-9: Exportar Datos Detallados para Análisis Externo
  Para complementar las visualizaciones interactivas del dashboard, el sistema debía proporcionar una forma de extraer datos crudos para análisis avanzados, auditorías o la creación de informes personalizados fuera de la plataforma. Esta historia de usuario se centra en la implementación de una robusta funcionalidad de exportación.
Implementación de la Funcionalidad de Exportación
  En cada una de las tres páginas de indicadores (Visitas, Servicios y Pacientes), se implementó una acción de "Exportar". Esta funcionalidad fue desarrollada utilizando la librería maatwebsite/excel, una herramienta estándar en el ecosistema de Laravel para la manipulación de hojas de cálculo.
  El flujo de trabajo para el usuario es el siguiente:
1. Al hacer clic en el botón "Exportar", se abre una ventana modal.
2. Dentro de la modal, el usuario puede definir los parámetros del reporte, principalmente el rango de fechas ("desde" y "hasta") y otros filtros contextuales relevantes.
3. Finalmente, el usuario puede elegir el formato de salida deseado, ya sea XLSX (para Excel) o CSV (formato de texto plano compatible con múltiples herramientas de análisis).
  Para cada tipo de reporte, se creó una clase Export dedicada que encapsula la lógica de la consulta a la base de datos, asegurando que los datos exportados respeten los filtros aplicados por el usuario.
  Esta capacidad de exportación es crucial, ya que dota al personal directivo y administrativo de la autonomía necesaria para realizar análisis profundos, cruzar datos con otras fuentes de información y cumplir con los requisitos de reportería externa. La Figura () muestra el modal de exportación.
  Esta funcionalidad, crucial para dotar al personal de autonomía para realizar análisis profundos, se gestiona a través de la ventana modal que permite al usuario definir los parámetros del reporte como el rango de fechas y el formato de salida, como se puede apreciar en la interfaz de la Figura ().

Figura 37. Modal de exportación de datos.
  
  
  2
  
  
  2
  
  
